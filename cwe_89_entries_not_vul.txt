Entry ID: 22073
: 22073
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/escape.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: static bool Curl_isunreserved(unsigned char in)
{
  switch (in) {
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
    case 'a': case 'b': case 'c': case 'd': case 'e':
    case 'f': case 'g': case 'h': case 'i': case 'j':
    case 'k': case 'l': case 'm': case 'n': case 'o':
    case 'p': case 'q': case 'r': case 's': case 't':
    case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':
    case 'A': case 'B': case 'C': case 'D': case 'E':
    case 'F': case 'G': case 'H': case 'I': case 'J':
    case 'K': case 'L': case 'M': case 'N': case 'O':
    case 'P': case 'Q': case 'R': case 'S': case 'T':
    case 'U': case 'V': case 'W': case 'X': case 'Y': case 'Z':
    case '-': case '.': case '_': case '~':
      return TRUE;
    default:
      break;
  }
  return FALSE;
}

func_before: static bool Curl_isunreserved(unsigned char in)
{
  switch (in) {
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
    case 'a': case 'b': case 'c': case 'd': case 'e':
    case 'f': case 'g': case 'h': case 'i': case 'j':
    case 'k': case 'l': case 'm': case 'n': case 'o':
    case 'p': case 'q': case 'r': case 's': case 't':
    case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':
    case 'A': case 'B': case 'C': case 'D': case 'E':
    case 'F': case 'G': case 'H': case 'I': case 'J':
    case 'K': case 'L': case 'M': case 'N': case 'O':
    case 'P': case 'Q': case 'R': case 'S': case 'T':
    case 'U': case 'V': case 'W': case 'X': case 'Y': case 'Z':
    case '-': case '.': case '_': case '~':
      return TRUE;
    default:
      break;
  }
  return FALSE;
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -31,6 +31,7 @@
 #include "urldata.h"
 #include "warnless.h"
 #include "non-ascii.h"
+#include "escape.h"
 
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)
   char *testing_ptr = NULL;
   unsigned char in; /* we need to treat the characters unsigned */
   size_t newlen = alloc;
-  int strindex=0;
+  size_t strindex=0;
   size_t length;
   CURLcode res;
 
@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)
 }
 
 /*
- * Unescapes the given URL escaped string of given length. Returns a
- * pointer to a malloced string with length given in *olen.
- * If length == 0, the length is assumed to be strlen(string).
- * If olen == NULL, no output length is stored.
+ * Curl_urldecode() URL decodes the given string.
+ *
+ * Optionally detects control characters (byte codes lower than 32) in the
+ * data and rejects such data.
+ *
+ * Returns a pointer to a malloced string in *ostring with length given in
+ * *olen. If length == 0, the length is assumed to be strlen(string).
+ *
  */
-char *curl_easy_unescape(CURL *handle, const char *string, int length,
-                         int *olen)
+CURLcode Curl_urldecode(struct SessionHandle *data,
+                        const char *string, size_t length,
+                        char **ostring, size_t *olen,
+                        bool reject_ctrl)
 {
-  int alloc = (length?length:(int)strlen(string))+1;
+  size_t alloc = (length?length:strlen(string))+1;
   char *ns = malloc(alloc);
   unsigned char in;
-  int strindex=0;
+  size_t strindex=0;
   unsigned long hex;
   CURLcode res;
 
   if(!ns)
-    return NULL;
+    return CURLE_OUT_OF_MEMORY;
 
   while(--alloc > 0) {
     in = *string;
@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,
 
       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */
 
-      res = Curl_convert_from_network(handle, &in, 1);
+      res = Curl_convert_from_network(data, &in, 1);
       if(res) {
         /* Curl_convert_from_network calls failf if unsuccessful */
         free(ns);
-        return NULL;
+        return res;
       }
 
       string+=2;
       alloc-=2;
     }
+    if(reject_ctrl && (in < 0x20)) {
+      free(ns);
+      return CURLE_URL_MALFORMAT;
+    }
 
     ns[strindex++] = in;
     string++;
@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,
   if(olen)
     /* store output size */
     *olen = strindex;
-  return ns;
+
+  if(ostring)
+    /* store output string */
+    *ostring = ns;
+
+  return CURLE_OK;
+}
+
+/*
+ * Unescapes the given URL escaped string of given length. Returns a
+ * pointer to a malloced string with length given in *olen.
+ * If length == 0, the length is assumed to be strlen(string).
+ * If olen == NULL, no output length is stored.
+ */
+char *curl_easy_unescape(CURL *handle, const char *string, int length,
+                         int *olen)
+{
+  char *str = NULL;
+  size_t inputlen = length;
+  size_t outputlen;
+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,
+                                FALSE);
+  if(res)
+    return NULL;
+  if(olen)
+    *olen = curlx_uztosi(outputlen);
+  return str;
 }
 
 /* For operating systems/environments that use different malloc/free
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: static bool Curl_isunreserved(unsigned char in)
{
  switch (in) {
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
    case 'a': case 'b': case 'c': case 'd': case 'e':
    case 'f': case 'g': case 'h': case 'i': case 'j':
    case 'k': case 'l': case 'm': case 'n': case 'o':
    case 'p': case 'q': case 'r': case 's': case 't':
    case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':
    case 'A': case 'B': case 'C': case 'D': case 'E':
    case 'F': case 'G': case 'H': case 'I': case 'J':
    case 'K': case 'L': case 'M': case 'N': case 'O':
    case 'P': case 'Q': case 'R': case 'S': case 'T':
    case 'U': case 'V': case 'W': case 'X': case 'Y': case 'Z':
    case '-': case '.': case '_': case '~':
      return TRUE;
    default:
      break;
  }
  return FALSE;
}


========================================

Entry ID: 22074
: 22074
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/escape.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: void curl_free(void *p)
{
  if(p)
    free(p);
}

func_before: void curl_free(void *p)
{
  if(p)
    free(p);
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -31,6 +31,7 @@
 #include "urldata.h"
 #include "warnless.h"
 #include "non-ascii.h"
+#include "escape.h"
 
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)
   char *testing_ptr = NULL;
   unsigned char in; /* we need to treat the characters unsigned */
   size_t newlen = alloc;
-  int strindex=0;
+  size_t strindex=0;
   size_t length;
   CURLcode res;
 
@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)
 }
 
 /*
- * Unescapes the given URL escaped string of given length. Returns a
- * pointer to a malloced string with length given in *olen.
- * If length == 0, the length is assumed to be strlen(string).
- * If olen == NULL, no output length is stored.
+ * Curl_urldecode() URL decodes the given string.
+ *
+ * Optionally detects control characters (byte codes lower than 32) in the
+ * data and rejects such data.
+ *
+ * Returns a pointer to a malloced string in *ostring with length given in
+ * *olen. If length == 0, the length is assumed to be strlen(string).
+ *
  */
-char *curl_easy_unescape(CURL *handle, const char *string, int length,
-                         int *olen)
+CURLcode Curl_urldecode(struct SessionHandle *data,
+                        const char *string, size_t length,
+                        char **ostring, size_t *olen,
+                        bool reject_ctrl)
 {
-  int alloc = (length?length:(int)strlen(string))+1;
+  size_t alloc = (length?length:strlen(string))+1;
   char *ns = malloc(alloc);
   unsigned char in;
-  int strindex=0;
+  size_t strindex=0;
   unsigned long hex;
   CURLcode res;
 
   if(!ns)
-    return NULL;
+    return CURLE_OUT_OF_MEMORY;
 
   while(--alloc > 0) {
     in = *string;
@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,
 
       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */
 
-      res = Curl_convert_from_network(handle, &in, 1);
+      res = Curl_convert_from_network(data, &in, 1);
       if(res) {
         /* Curl_convert_from_network calls failf if unsuccessful */
         free(ns);
-        return NULL;
+        return res;
       }
 
       string+=2;
       alloc-=2;
     }
+    if(reject_ctrl && (in < 0x20)) {
+      free(ns);
+      return CURLE_URL_MALFORMAT;
+    }
 
     ns[strindex++] = in;
     string++;
@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,
   if(olen)
     /* store output size */
     *olen = strindex;
-  return ns;
+
+  if(ostring)
+    /* store output string */
+    *ostring = ns;
+
+  return CURLE_OK;
+}
+
+/*
+ * Unescapes the given URL escaped string of given length. Returns a
+ * pointer to a malloced string with length given in *olen.
+ * If length == 0, the length is assumed to be strlen(string).
+ * If olen == NULL, no output length is stored.
+ */
+char *curl_easy_unescape(CURL *handle, const char *string, int length,
+                         int *olen)
+{
+  char *str = NULL;
+  size_t inputlen = length;
+  size_t outputlen;
+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,
+                                FALSE);
+  if(res)
+    return NULL;
+  if(olen)
+    *olen = curlx_uztosi(outputlen);
+  return str;
 }
 
 /* For operating systems/environments that use different malloc/free
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: void curl_free(void *p)
{
  if(p)
    free(p);
}


========================================

Entry ID: 22075
: 22075
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/escape.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: char *curl_unescape(const char *string, int length)
{
  return curl_easy_unescape(NULL, string, length, NULL);
}

func_before: char *curl_unescape(const char *string, int length)
{
  return curl_easy_unescape(NULL, string, length, NULL);
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -31,6 +31,7 @@
 #include "urldata.h"
 #include "warnless.h"
 #include "non-ascii.h"
+#include "escape.h"
 
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)
   char *testing_ptr = NULL;
   unsigned char in; /* we need to treat the characters unsigned */
   size_t newlen = alloc;
-  int strindex=0;
+  size_t strindex=0;
   size_t length;
   CURLcode res;
 
@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)
 }
 
 /*
- * Unescapes the given URL escaped string of given length. Returns a
- * pointer to a malloced string with length given in *olen.
- * If length == 0, the length is assumed to be strlen(string).
- * If olen == NULL, no output length is stored.
+ * Curl_urldecode() URL decodes the given string.
+ *
+ * Optionally detects control characters (byte codes lower than 32) in the
+ * data and rejects such data.
+ *
+ * Returns a pointer to a malloced string in *ostring with length given in
+ * *olen. If length == 0, the length is assumed to be strlen(string).
+ *
  */
-char *curl_easy_unescape(CURL *handle, const char *string, int length,
-                         int *olen)
+CURLcode Curl_urldecode(struct SessionHandle *data,
+                        const char *string, size_t length,
+                        char **ostring, size_t *olen,
+                        bool reject_ctrl)
 {
-  int alloc = (length?length:(int)strlen(string))+1;
+  size_t alloc = (length?length:strlen(string))+1;
   char *ns = malloc(alloc);
   unsigned char in;
-  int strindex=0;
+  size_t strindex=0;
   unsigned long hex;
   CURLcode res;
 
   if(!ns)
-    return NULL;
+    return CURLE_OUT_OF_MEMORY;
 
   while(--alloc > 0) {
     in = *string;
@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,
 
       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */
 
-      res = Curl_convert_from_network(handle, &in, 1);
+      res = Curl_convert_from_network(data, &in, 1);
       if(res) {
         /* Curl_convert_from_network calls failf if unsuccessful */
         free(ns);
-        return NULL;
+        return res;
       }
 
       string+=2;
       alloc-=2;
     }
+    if(reject_ctrl && (in < 0x20)) {
+      free(ns);
+      return CURLE_URL_MALFORMAT;
+    }
 
     ns[strindex++] = in;
     string++;
@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,
   if(olen)
     /* store output size */
     *olen = strindex;
-  return ns;
+
+  if(ostring)
+    /* store output string */
+    *ostring = ns;
+
+  return CURLE_OK;
+}
+
+/*
+ * Unescapes the given URL escaped string of given length. Returns a
+ * pointer to a malloced string with length given in *olen.
+ * If length == 0, the length is assumed to be strlen(string).
+ * If olen == NULL, no output length is stored.
+ */
+char *curl_easy_unescape(CURL *handle, const char *string, int length,
+                         int *olen)
+{
+  char *str = NULL;
+  size_t inputlen = length;
+  size_t outputlen;
+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,
+                                FALSE);
+  if(res)
+    return NULL;
+  if(olen)
+    *olen = curlx_uztosi(outputlen);
+  return str;
 }
 
 /* For operating systems/environments that use different malloc/free
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: char *curl_unescape(const char *string, int length)
{
  return curl_easy_unescape(NULL, string, length, NULL);
}


========================================

Entry ID: 22076
: 22076
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/imap.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: static const char *getcmdid(struct connectdata *conn)
{
  static const char * const ids[]= {
    "A",
    "B",
    "C",
    "D"
  };

  struct imap_conn *imapc = &conn->proto.imapc;

  /* get the next id, but wrap at end of table */
  imapc->cmdid = (int)((imapc->cmdid+1) % (sizeof(ids)/sizeof(ids[0])));

  return ids[imapc->cmdid];
}

func_before: static const char *getcmdid(struct connectdata *conn)
{
  static const char * const ids[]= {
    "A",
    "B",
    "C",
    "D"
  };

  struct imap_conn *imapc = &conn->proto.imapc;

  /* get the next id, but wrap at end of table */
  imapc->cmdid = (int)((imapc->cmdid+1) % (sizeof(ids)/sizeof(ids[0])));

  return ids[imapc->cmdid];
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
-  int len;
 
   if(!*path)
     path = "INBOX";
 
   /* url decode the path and use this mailbox */
-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
-  if(!imapc->mailbox)
-    return CURLE_OUT_OF_MEMORY;
-
-  return CURLE_OK;
+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
 
 /* call this when the DO phase has completed */
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: static const char *getcmdid(struct connectdata *conn)
{
  static const char * const ids[]= {
    "A",
    "B",
    "C",
    "D"
  };

  struct imap_conn *imapc = &conn->proto.imapc;

  /* get the next id, but wrap at end of table */
  imapc->cmdid = (int)((imapc->cmdid+1) % (sizeof(ids)/sizeof(ids[0])));

  return ids[imapc->cmdid];
}


========================================

Entry ID: 22077
: 22077
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/imap.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: static CURLcode imap_connect(struct connectdata *conn,
                                 bool *done) /* see description above */
{
  CURLcode result;
  struct imap_conn *imapc = &conn->proto.imapc;
  struct SessionHandle *data=conn->data;
  struct pingpong *pp = &imapc->pp;

  *done = FALSE; /* default to not done yet */

  /* If there already is a protocol-specific struct allocated for this
     sessionhandle, deal with it */
  Curl_reset_reqproto(conn);

  result = imap_init(conn);
  if(CURLE_OK != result)
    return result;

  /* We always support persistent connections on imap */
  conn->bits.close = FALSE;

  pp->response_time = RESP_TIMEOUT; /* set default response time-out */
  pp->statemach_act = imap_statemach_act;
  pp->endofresp = imap_endofresp;
  pp->conn = conn;

  if(conn->bits.tunnel_proxy && conn->bits.httpproxy) {
    /* for IMAP over HTTP proxy */
    struct HTTP http_proxy;
    struct FTP *imap_save;

    /* BLOCKING */
    /* We want "seamless" IMAP operations through HTTP proxy tunnel */

    /* Curl_proxyCONNECT is based on a pointer to a struct HTTP at the member
     * conn->proto.http; we want IMAP through HTTP and we have to change the
     * member temporarily for connecting to the HTTP proxy. After
     * Curl_proxyCONNECT we have to set back the member to the original struct
     * IMAP pointer
     */
    imap_save = data->state.proto.imap;
    memset(&http_proxy, 0, sizeof(http_proxy));
    data->state.proto.http = &http_proxy;

    result = Curl_proxyCONNECT(conn, FIRSTSOCKET,
                               conn->host.name, conn->remote_port);

    data->state.proto.imap = imap_save;

    if(CURLE_OK != result)
      return result;
  }

  if((conn->handler->flags & PROTOPT_SSL) &&
     data->state.used_interface != Curl_if_multi) {
    /* BLOCKING */
    result = Curl_ssl_connect(conn, FIRSTSOCKET);
    if(result)
      return result;
  }

  Curl_pp_init(pp); /* init generic pingpong data */

  /* When we connect, we start in the state where we await the server greeting
     response */
  state(conn, IMAP_SERVERGREET);
  imapc->idstr = "*"; /* we start off waiting for a '*' response */

  if(data->state.used_interface == Curl_if_multi)
    result = imap_multi_statemach(conn, done);
  else {
    result = imap_easy_statemach(conn);
    if(!result)
      *done = TRUE;
  }

  return result;
}

func_before: static CURLcode imap_connect(struct connectdata *conn,
                                 bool *done) /* see description above */
{
  CURLcode result;
  struct imap_conn *imapc = &conn->proto.imapc;
  struct SessionHandle *data=conn->data;
  struct pingpong *pp = &imapc->pp;

  *done = FALSE; /* default to not done yet */

  /* If there already is a protocol-specific struct allocated for this
     sessionhandle, deal with it */
  Curl_reset_reqproto(conn);

  result = imap_init(conn);
  if(CURLE_OK != result)
    return result;

  /* We always support persistent connections on imap */
  conn->bits.close = FALSE;

  pp->response_time = RESP_TIMEOUT; /* set default response time-out */
  pp->statemach_act = imap_statemach_act;
  pp->endofresp = imap_endofresp;
  pp->conn = conn;

  if(conn->bits.tunnel_proxy && conn->bits.httpproxy) {
    /* for IMAP over HTTP proxy */
    struct HTTP http_proxy;
    struct FTP *imap_save;

    /* BLOCKING */
    /* We want "seamless" IMAP operations through HTTP proxy tunnel */

    /* Curl_proxyCONNECT is based on a pointer to a struct HTTP at the member
     * conn->proto.http; we want IMAP through HTTP and we have to change the
     * member temporarily for connecting to the HTTP proxy. After
     * Curl_proxyCONNECT we have to set back the member to the original struct
     * IMAP pointer
     */
    imap_save = data->state.proto.imap;
    memset(&http_proxy, 0, sizeof(http_proxy));
    data->state.proto.http = &http_proxy;

    result = Curl_proxyCONNECT(conn, FIRSTSOCKET,
                               conn->host.name, conn->remote_port);

    data->state.proto.imap = imap_save;

    if(CURLE_OK != result)
      return result;
  }

  if((conn->handler->flags & PROTOPT_SSL) &&
     data->state.used_interface != Curl_if_multi) {
    /* BLOCKING */
    result = Curl_ssl_connect(conn, FIRSTSOCKET);
    if(result)
      return result;
  }

  Curl_pp_init(pp); /* init generic pingpong data */

  /* When we connect, we start in the state where we await the server greeting
     response */
  state(conn, IMAP_SERVERGREET);
  imapc->idstr = "*"; /* we start off waiting for a '*' response */

  if(data->state.used_interface == Curl_if_multi)
    result = imap_multi_statemach(conn, done);
  else {
    result = imap_easy_statemach(conn);
    if(!result)
      *done = TRUE;
  }

  return result;
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
-  int len;
 
   if(!*path)
     path = "INBOX";
 
   /* url decode the path and use this mailbox */
-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
-  if(!imapc->mailbox)
-    return CURLE_OUT_OF_MEMORY;
-
-  return CURLE_OK;
+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
 
 /* call this when the DO phase has completed */
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: static CURLcode imap_connect(struct connectdata *conn,
                                 bool *done) /* see description above */
{
  CURLcode result;
  struct imap_conn *imapc = &conn->proto.imapc;
  struct SessionHandle *data=conn->data;
  struct pingpong *pp = &imapc->pp;

  *done = FALSE; /* default to not done yet */

  /* If there already is a protocol-specific struct allocated for this
     sessionhandle, deal with it */
  Curl_reset_reqproto(conn);

  result = imap_init(conn);
  if(CURLE_OK != result)
    return result;

  /* We always support persistent connections on imap */
  conn->bits.close = FALSE;

  pp->response_time = RESP_TIMEOUT; /* set default response time-out */
  pp->statemach_act = imap_statemach_act;
  pp->endofresp = imap_endofresp;
  pp->conn = conn;

  if(conn->bits.tunnel_proxy && conn->bits.httpproxy) {
    /* for IMAP over HTTP proxy */
    struct HTTP http_proxy;
    struct FTP *imap_save;

    /* BLOCKING */
    /* We want "seamless" IMAP operations through HTTP proxy tunnel */

    /* Curl_proxyCONNECT is based on a pointer to a struct HTTP at the member
     * conn->proto.http; we want IMAP through HTTP and we have to change the
     * member temporarily for connecting to the HTTP proxy. After
     * Curl_proxyCONNECT we have to set back the member to the original struct
     * IMAP pointer
     */
    imap_save = data->state.proto.imap;
    memset(&http_proxy, 0, sizeof(http_proxy));
    data->state.proto.http = &http_proxy;

    result = Curl_proxyCONNECT(conn, FIRSTSOCKET,
                               conn->host.name, conn->remote_port);

    data->state.proto.imap = imap_save;

    if(CURLE_OK != result)
      return result;
  }

  if((conn->handler->flags & PROTOPT_SSL) &&
     data->state.used_interface != Curl_if_multi) {
    /* BLOCKING */
    result = Curl_ssl_connect(conn, FIRSTSOCKET);
    if(result)
      return result;
  }

  Curl_pp_init(pp); /* init generic pingpong data */

  /* When we connect, we start in the state where we await the server greeting
     response */
  state(conn, IMAP_SERVERGREET);
  imapc->idstr = "*"; /* we start off waiting for a '*' response */

  if(data->state.used_interface == Curl_if_multi)
    result = imap_multi_statemach(conn, done);
  else {
    result = imap_easy_statemach(conn);
    if(!result)
      *done = TRUE;
  }

  return result;
}


========================================

Entry ID: 22078
: 22078
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/imap.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: static CURLcode imap_disconnect(struct connectdata *conn, bool dead_connection)
{
  struct imap_conn *imapc= &conn->proto.imapc;

  /* The IMAP session may or may not have been allocated/setup at this
     point! */
  if(!dead_connection && imapc->pp.conn)
    (void)imap_logout(conn); /* ignore errors on the LOGOUT */

  Curl_pp_disconnect(&imapc->pp);

  Curl_safefree(imapc->mailbox);

  return CURLE_OK;
}

func_before: static CURLcode imap_disconnect(struct connectdata *conn, bool dead_connection)
{
  struct imap_conn *imapc= &conn->proto.imapc;

  /* The IMAP session may or may not have been allocated/setup at this
     point! */
  if(!dead_connection && imapc->pp.conn)
    (void)imap_logout(conn); /* ignore errors on the LOGOUT */

  Curl_pp_disconnect(&imapc->pp);

  Curl_safefree(imapc->mailbox);

  return CURLE_OK;
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
-  int len;
 
   if(!*path)
     path = "INBOX";
 
   /* url decode the path and use this mailbox */
-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
-  if(!imapc->mailbox)
-    return CURLE_OUT_OF_MEMORY;
-
-  return CURLE_OK;
+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
 
 /* call this when the DO phase has completed */
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: static CURLcode imap_disconnect(struct connectdata *conn, bool dead_connection)
{
  struct imap_conn *imapc= &conn->proto.imapc;

  /* The IMAP session may or may not have been allocated/setup at this
     point! */
  if(!dead_connection && imapc->pp.conn)
    (void)imap_logout(conn); /* ignore errors on the LOGOUT */

  Curl_pp_disconnect(&imapc->pp);

  Curl_safefree(imapc->mailbox);

  return CURLE_OK;
}


========================================

Entry ID: 22079
: 22079
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/imap.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: static CURLcode imap_do(struct connectdata *conn, bool *done)
{
  CURLcode retcode = CURLE_OK;

  *done = FALSE; /* default to false */

  /*
    Since connections can be re-used between SessionHandles, this might be a
    connection already existing but on a fresh SessionHandle struct so we must
    make sure we have a good 'struct IMAP' to play with. For new connections,
    the struct IMAP is allocated and setup in the imap_connect() function.
  */
  Curl_reset_reqproto(conn);
  retcode = imap_init(conn);
  if(retcode)
    return retcode;

  retcode = imap_parse_url_path(conn);
  if(retcode)
    return retcode;

  retcode = imap_regular_transfer(conn, done);

  return retcode;
}

func_before: static CURLcode imap_do(struct connectdata *conn, bool *done)
{
  CURLcode retcode = CURLE_OK;

  *done = FALSE; /* default to false */

  /*
    Since connections can be re-used between SessionHandles, this might be a
    connection already existing but on a fresh SessionHandle struct so we must
    make sure we have a good 'struct IMAP' to play with. For new connections,
    the struct IMAP is allocated and setup in the imap_connect() function.
  */
  Curl_reset_reqproto(conn);
  retcode = imap_init(conn);
  if(retcode)
    return retcode;

  retcode = imap_parse_url_path(conn);
  if(retcode)
    return retcode;

  retcode = imap_regular_transfer(conn, done);

  return retcode;
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
-  int len;
 
   if(!*path)
     path = "INBOX";
 
   /* url decode the path and use this mailbox */
-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
-  if(!imapc->mailbox)
-    return CURLE_OUT_OF_MEMORY;
-
-  return CURLE_OK;
+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
 
 /* call this when the DO phase has completed */
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: static CURLcode imap_do(struct connectdata *conn, bool *done)
{
  CURLcode retcode = CURLE_OK;

  *done = FALSE; /* default to false */

  /*
    Since connections can be re-used between SessionHandles, this might be a
    connection already existing but on a fresh SessionHandle struct so we must
    make sure we have a good 'struct IMAP' to play with. For new connections,
    the struct IMAP is allocated and setup in the imap_connect() function.
  */
  Curl_reset_reqproto(conn);
  retcode = imap_init(conn);
  if(retcode)
    return retcode;

  retcode = imap_parse_url_path(conn);
  if(retcode)
    return retcode;

  retcode = imap_regular_transfer(conn, done);

  return retcode;
}


========================================

Entry ID: 22080
: 22080
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/imap.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: static CURLcode imap_doing(struct connectdata *conn,
                               bool *dophase_done)
{
  CURLcode result;
  result = imap_multi_statemach(conn, dophase_done);

  if(*dophase_done) {
    result = imap_dophase_done(conn, FALSE /* not connected */);

    DEBUGF(infof(conn->data, "DO phase is complete\n"));
  }
  return result;
}

func_before: static CURLcode imap_doing(struct connectdata *conn,
                               bool *dophase_done)
{
  CURLcode result;
  result = imap_multi_statemach(conn, dophase_done);

  if(*dophase_done) {
    result = imap_dophase_done(conn, FALSE /* not connected */);

    DEBUGF(infof(conn->data, "DO phase is complete\n"));
  }
  return result;
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
-  int len;
 
   if(!*path)
     path = "INBOX";
 
   /* url decode the path and use this mailbox */
-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
-  if(!imapc->mailbox)
-    return CURLE_OUT_OF_MEMORY;
-
-  return CURLE_OK;
+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
 
 /* call this when the DO phase has completed */
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: static CURLcode imap_doing(struct connectdata *conn,
                               bool *dophase_done)
{
  CURLcode result;
  result = imap_multi_statemach(conn, dophase_done);

  if(*dophase_done) {
    result = imap_dophase_done(conn, FALSE /* not connected */);

    DEBUGF(infof(conn->data, "DO phase is complete\n"));
  }
  return result;
}


========================================

Entry ID: 22081
: 22081
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/imap.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: static CURLcode imap_done(struct connectdata *conn, CURLcode status,
                          bool premature)
{
  struct SessionHandle *data = conn->data;
  struct FTP *imap = data->state.proto.imap;
  CURLcode result=CURLE_OK;
  (void)premature;

  if(!imap)
    /* When the easy handle is removed from the multi while libcurl is still
     * trying to resolve the host name, it seems that the imap struct is not
     * yet initialized, but the removal action calls Curl_done() which calls
     * this function. So we simply return success if no imap pointer is set.
     */
    return CURLE_OK;

  if(status) {
    conn->bits.close = TRUE; /* marked for closure */
    result = status;      /* use the already set error code */
  }

  /* clear these for next connection */
  imap->transfer = FTPTRANSFER_BODY;

  return result;
}

func_before: static CURLcode imap_done(struct connectdata *conn, CURLcode status,
                          bool premature)
{
  struct SessionHandle *data = conn->data;
  struct FTP *imap = data->state.proto.imap;
  CURLcode result=CURLE_OK;
  (void)premature;

  if(!imap)
    /* When the easy handle is removed from the multi while libcurl is still
     * trying to resolve the host name, it seems that the imap struct is not
     * yet initialized, but the removal action calls Curl_done() which calls
     * this function. So we simply return success if no imap pointer is set.
     */
    return CURLE_OK;

  if(status) {
    conn->bits.close = TRUE; /* marked for closure */
    result = status;      /* use the already set error code */
  }

  /* clear these for next connection */
  imap->transfer = FTPTRANSFER_BODY;

  return result;
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
-  int len;
 
   if(!*path)
     path = "INBOX";
 
   /* url decode the path and use this mailbox */
-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
-  if(!imapc->mailbox)
-    return CURLE_OUT_OF_MEMORY;
-
-  return CURLE_OK;
+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
 
 /* call this when the DO phase has completed */
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: static CURLcode imap_done(struct connectdata *conn, CURLcode status,
                          bool premature)
{
  struct SessionHandle *data = conn->data;
  struct FTP *imap = data->state.proto.imap;
  CURLcode result=CURLE_OK;
  (void)premature;

  if(!imap)
    /* When the easy handle is removed from the multi while libcurl is still
     * trying to resolve the host name, it seems that the imap struct is not
     * yet initialized, but the removal action calls Curl_done() which calls
     * this function. So we simply return success if no imap pointer is set.
     */
    return CURLE_OK;

  if(status) {
    conn->bits.close = TRUE; /* marked for closure */
    result = status;      /* use the already set error code */
  }

  /* clear these for next connection */
  imap->transfer = FTPTRANSFER_BODY;

  return result;
}


========================================

Entry ID: 22082
: 22082
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/imap.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: static CURLcode imap_dophase_done(struct connectdata *conn,
                                  bool connected)
{
  struct FTP *imap = conn->data->state.proto.imap;
  (void)connected;

  if(imap->transfer != FTPTRANSFER_BODY)
    /* no data to transfer */
    Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);

  return CURLE_OK;
}

func_before: static CURLcode imap_dophase_done(struct connectdata *conn,
                                  bool connected)
{
  struct FTP *imap = conn->data->state.proto.imap;
  (void)connected;

  if(imap->transfer != FTPTRANSFER_BODY)
    /* no data to transfer */
    Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);

  return CURLE_OK;
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
-  int len;
 
   if(!*path)
     path = "INBOX";
 
   /* url decode the path and use this mailbox */
-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
-  if(!imapc->mailbox)
-    return CURLE_OUT_OF_MEMORY;
-
-  return CURLE_OK;
+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
 
 /* call this when the DO phase has completed */
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: static CURLcode imap_dophase_done(struct connectdata *conn,
                                  bool connected)
{
  struct FTP *imap = conn->data->state.proto.imap;
  (void)connected;

  if(imap->transfer != FTPTRANSFER_BODY)
    /* no data to transfer */
    Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);

  return CURLE_OK;
}


========================================

Entry ID: 22083
: 22083
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/imap.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: static CURLcode imap_easy_statemach(struct connectdata *conn)
{
  struct imap_conn *imapc = &conn->proto.imapc;
  struct pingpong *pp = &imapc->pp;
  CURLcode result = CURLE_OK;

  while(imapc->state != IMAP_STOP) {
    result = Curl_pp_easy_statemach(pp);
    if(result)
      break;
  }

  return result;
}

func_before: static CURLcode imap_easy_statemach(struct connectdata *conn)
{
  struct imap_conn *imapc = &conn->proto.imapc;
  struct pingpong *pp = &imapc->pp;
  CURLcode result = CURLE_OK;

  while(imapc->state != IMAP_STOP) {
    result = Curl_pp_easy_statemach(pp);
    if(result)
      break;
  }

  return result;
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
-  int len;
 
   if(!*path)
     path = "INBOX";
 
   /* url decode the path and use this mailbox */
-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
-  if(!imapc->mailbox)
-    return CURLE_OUT_OF_MEMORY;
-
-  return CURLE_OK;
+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
 
 /* call this when the DO phase has completed */
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: static CURLcode imap_easy_statemach(struct connectdata *conn)
{
  struct imap_conn *imapc = &conn->proto.imapc;
  struct pingpong *pp = &imapc->pp;
  CURLcode result = CURLE_OK;

  while(imapc->state != IMAP_STOP) {
    result = Curl_pp_easy_statemach(pp);
    if(result)
      break;
  }

  return result;
}


========================================

Entry ID: 22084
: 22084
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/imap.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: static int imap_endofresp(struct pingpong *pp, int *resp)
{
  char *line = pp->linestart_resp;
  size_t len = pp->nread_resp;
  struct imap_conn *imapc = &pp->conn->proto.imapc;
  const char *id = imapc->idstr;
  size_t id_len = strlen(id);

  if(len >= id_len + 3) {
    if(!memcmp(id, line, id_len) && (line[id_len] == ' ') ) {
      /* end of response */
      *resp = line[id_len+1]; /* O, N or B */
      return TRUE;
    }
    else if((imapc->state == IMAP_FETCH) &&
            !memcmp("* ", line, 2) ) {
      /* FETCH response we're interested in */
      *resp = '*';
      return TRUE;
    }
  }
  return FALSE; /* nothing for us */
}

func_before: static int imap_endofresp(struct pingpong *pp, int *resp)
{
  char *line = pp->linestart_resp;
  size_t len = pp->nread_resp;
  struct imap_conn *imapc = &pp->conn->proto.imapc;
  const char *id = imapc->idstr;
  size_t id_len = strlen(id);

  if(len >= id_len + 3) {
    if(!memcmp(id, line, id_len) && (line[id_len] == ' ') ) {
      /* end of response */
      *resp = line[id_len+1]; /* O, N or B */
      return TRUE;
    }
    else if((imapc->state == IMAP_FETCH) &&
            !memcmp("* ", line, 2) ) {
      /* FETCH response we're interested in */
      *resp = '*';
      return TRUE;
    }
  }
  return FALSE; /* nothing for us */
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
-  int len;
 
   if(!*path)
     path = "INBOX";
 
   /* url decode the path and use this mailbox */
-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
-  if(!imapc->mailbox)
-    return CURLE_OUT_OF_MEMORY;
-
-  return CURLE_OK;
+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
 
 /* call this when the DO phase has completed */
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: static int imap_endofresp(struct pingpong *pp, int *resp)
{
  char *line = pp->linestart_resp;
  size_t len = pp->nread_resp;
  struct imap_conn *imapc = &pp->conn->proto.imapc;
  const char *id = imapc->idstr;
  size_t id_len = strlen(id);

  if(len >= id_len + 3) {
    if(!memcmp(id, line, id_len) && (line[id_len] == ' ') ) {
      /* end of response */
      *resp = line[id_len+1]; /* O, N or B */
      return TRUE;
    }
    else if((imapc->state == IMAP_FETCH) &&
            !memcmp("* ", line, 2) ) {
      /* FETCH response we're interested in */
      *resp = '*';
      return TRUE;
    }
  }
  return FALSE; /* nothing for us */
}


========================================

Entry ID: 22085
: 22085
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/imap.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: static CURLcode imap_fetch(struct connectdata *conn)
{
  CURLcode result = CURLE_OK;
  const char *str;

  str = getcmdid(conn);

  /* TODO: make this select the correct mail
   * Use "1 body[text]" to get the full mail body of mail 1
   */
  result = imapsendf(conn, str, "%s FETCH 1 BODY[TEXT]", str);
  if(result)
    return result;

  /*
   * When issued, the server will respond with a single line similar to
   * '* 1 FETCH (BODY[TEXT] {2021}'
   *
   * Identifying the fetch and how many bytes of contents we can expect. We
   * must extract that number before continuing to "download as usual".
   */

  state(conn, IMAP_FETCH);
  return result;
}

func_before: static CURLcode imap_fetch(struct connectdata *conn)
{
  CURLcode result = CURLE_OK;
  const char *str;

  str = getcmdid(conn);

  /* TODO: make this select the correct mail
   * Use "1 body[text]" to get the full mail body of mail 1
   */
  result = imapsendf(conn, str, "%s FETCH 1 BODY[TEXT]", str);
  if(result)
    return result;

  /*
   * When issued, the server will respond with a single line similar to
   * '* 1 FETCH (BODY[TEXT] {2021}'
   *
   * Identifying the fetch and how many bytes of contents we can expect. We
   * must extract that number before continuing to "download as usual".
   */

  state(conn, IMAP_FETCH);
  return result;
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
-  int len;
 
   if(!*path)
     path = "INBOX";
 
   /* url decode the path and use this mailbox */
-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
-  if(!imapc->mailbox)
-    return CURLE_OUT_OF_MEMORY;
-
-  return CURLE_OK;
+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
 
 /* call this when the DO phase has completed */
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: static CURLcode imap_fetch(struct connectdata *conn)
{
  CURLcode result = CURLE_OK;
  const char *str;

  str = getcmdid(conn);

  /* TODO: make this select the correct mail
   * Use "1 body[text]" to get the full mail body of mail 1
   */
  result = imapsendf(conn, str, "%s FETCH 1 BODY[TEXT]", str);
  if(result)
    return result;

  /*
   * When issued, the server will respond with a single line similar to
   * '* 1 FETCH (BODY[TEXT] {2021}'
   *
   * Identifying the fetch and how many bytes of contents we can expect. We
   * must extract that number before continuing to "download as usual".
   */

  state(conn, IMAP_FETCH);
  return result;
}


========================================

Entry ID: 22086
: 22086
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/imap.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: static int imap_getsock(struct connectdata *conn,
                        curl_socket_t *socks,
                        int numsocks)
{
  return Curl_pp_getsock(&conn->proto.imapc.pp, socks, numsocks);
}

func_before: static int imap_getsock(struct connectdata *conn,
                        curl_socket_t *socks,
                        int numsocks)
{
  return Curl_pp_getsock(&conn->proto.imapc.pp, socks, numsocks);
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
-  int len;
 
   if(!*path)
     path = "INBOX";
 
   /* url decode the path and use this mailbox */
-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
-  if(!imapc->mailbox)
-    return CURLE_OUT_OF_MEMORY;
-
-  return CURLE_OK;
+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
 
 /* call this when the DO phase has completed */
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: static int imap_getsock(struct connectdata *conn,
                        curl_socket_t *socks,
                        int numsocks)
{
  return Curl_pp_getsock(&conn->proto.imapc.pp, socks, numsocks);
}


========================================

Entry ID: 22087
: 22087
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/imap.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: static CURLcode imap_init(struct connectdata *conn)
{
  struct SessionHandle *data = conn->data;
  struct FTP *imap = data->state.proto.imap;
  if(!imap) {
    imap = data->state.proto.imap = calloc(sizeof(struct FTP), 1);
    if(!imap)
      return CURLE_OUT_OF_MEMORY;
  }

  /* get some initial data into the imap struct */
  imap->bytecountp = &data->req.bytecount;

  /* No need to duplicate user+password, the connectdata struct won't change
     during a session, but we re-init them here since on subsequent inits
     since the conn struct may have changed or been replaced.
  */
  imap->user = conn->user;
  imap->passwd = conn->passwd;

  return CURLE_OK;
}

func_before: static CURLcode imap_init(struct connectdata *conn)
{
  struct SessionHandle *data = conn->data;
  struct FTP *imap = data->state.proto.imap;
  if(!imap) {
    imap = data->state.proto.imap = calloc(sizeof(struct FTP), 1);
    if(!imap)
      return CURLE_OUT_OF_MEMORY;
  }

  /* get some initial data into the imap struct */
  imap->bytecountp = &data->req.bytecount;

  /* No need to duplicate user+password, the connectdata struct won't change
     during a session, but we re-init them here since on subsequent inits
     since the conn struct may have changed or been replaced.
  */
  imap->user = conn->user;
  imap->passwd = conn->passwd;

  return CURLE_OK;
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
-  int len;
 
   if(!*path)
     path = "INBOX";
 
   /* url decode the path and use this mailbox */
-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
-  if(!imapc->mailbox)
-    return CURLE_OUT_OF_MEMORY;
-
-  return CURLE_OK;
+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
 
 /* call this when the DO phase has completed */
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: static CURLcode imap_init(struct connectdata *conn)
{
  struct SessionHandle *data = conn->data;
  struct FTP *imap = data->state.proto.imap;
  if(!imap) {
    imap = data->state.proto.imap = calloc(sizeof(struct FTP), 1);
    if(!imap)
      return CURLE_OUT_OF_MEMORY;
  }

  /* get some initial data into the imap struct */
  imap->bytecountp = &data->req.bytecount;

  /* No need to duplicate user+password, the connectdata struct won't change
     during a session, but we re-init them here since on subsequent inits
     since the conn struct may have changed or been replaced.
  */
  imap->user = conn->user;
  imap->passwd = conn->passwd;

  return CURLE_OK;
}


========================================

Entry ID: 22088
: 22088
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/imap.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: static CURLcode imap_logout(struct connectdata *conn)
{
  CURLcode result = CURLE_OK;
  const char *str;

  str = getcmdid(conn);

  result = imapsendf(conn, str, "%s LOGOUT", str, NULL);
  if(result)
    return result;
  state(conn, IMAP_LOGOUT);

  result = imap_easy_statemach(conn);

  return result;
}

func_before: static CURLcode imap_logout(struct connectdata *conn)
{
  CURLcode result = CURLE_OK;
  const char *str;

  str = getcmdid(conn);

  result = imapsendf(conn, str, "%s LOGOUT", str, NULL);
  if(result)
    return result;
  state(conn, IMAP_LOGOUT);

  result = imap_easy_statemach(conn);

  return result;
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
-  int len;
 
   if(!*path)
     path = "INBOX";
 
   /* url decode the path and use this mailbox */
-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
-  if(!imapc->mailbox)
-    return CURLE_OUT_OF_MEMORY;
-
-  return CURLE_OK;
+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
 
 /* call this when the DO phase has completed */
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: static CURLcode imap_logout(struct connectdata *conn)
{
  CURLcode result = CURLE_OK;
  const char *str;

  str = getcmdid(conn);

  result = imapsendf(conn, str, "%s LOGOUT", str, NULL);
  if(result)
    return result;
  state(conn, IMAP_LOGOUT);

  result = imap_easy_statemach(conn);

  return result;
}


========================================

Entry ID: 22089
: 22089
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/imap.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: static CURLcode imap_multi_statemach(struct connectdata *conn,
                                         bool *done)
{
  struct imap_conn *imapc = &conn->proto.imapc;
  CURLcode result;

  if((conn->handler->flags & PROTOPT_SSL) && !imapc->ssldone)
    result = Curl_ssl_connect_nonblocking(conn, FIRSTSOCKET, &imapc->ssldone);
  else
    result = Curl_pp_multi_statemach(&imapc->pp);

  *done = (imapc->state == IMAP_STOP) ? TRUE : FALSE;

  return result;
}

func_before: static CURLcode imap_multi_statemach(struct connectdata *conn,
                                         bool *done)
{
  struct imap_conn *imapc = &conn->proto.imapc;
  CURLcode result;

  if((conn->handler->flags & PROTOPT_SSL) && !imapc->ssldone)
    result = Curl_ssl_connect_nonblocking(conn, FIRSTSOCKET, &imapc->ssldone);
  else
    result = Curl_pp_multi_statemach(&imapc->pp);

  *done = (imapc->state == IMAP_STOP) ? TRUE : FALSE;

  return result;
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
-  int len;
 
   if(!*path)
     path = "INBOX";
 
   /* url decode the path and use this mailbox */
-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
-  if(!imapc->mailbox)
-    return CURLE_OUT_OF_MEMORY;
-
-  return CURLE_OK;
+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
 
 /* call this when the DO phase has completed */
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: static CURLcode imap_multi_statemach(struct connectdata *conn,
                                         bool *done)
{
  struct imap_conn *imapc = &conn->proto.imapc;
  CURLcode result;

  if((conn->handler->flags & PROTOPT_SSL) && !imapc->ssldone)
    result = Curl_ssl_connect_nonblocking(conn, FIRSTSOCKET, &imapc->ssldone);
  else
    result = Curl_pp_multi_statemach(&imapc->pp);

  *done = (imapc->state == IMAP_STOP) ? TRUE : FALSE;

  return result;
}


========================================

Entry ID: 22090
: 22090
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/imap.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: CURLcode imap_perform(struct connectdata *conn,
                     bool *connected,  /* connect status after PASV / PORT */
                     bool *dophase_done)
{
  /* this is IMAP and no proxy */
  CURLcode result=CURLE_OK;

  DEBUGF(infof(conn->data, "DO phase starts\n"));

  if(conn->data->set.opt_no_body) {
    /* requested no body means no transfer... */
    struct FTP *imap = conn->data->state.proto.imap;
    imap->transfer = FTPTRANSFER_INFO;
  }

  *dophase_done = FALSE; /* not done yet */

  /* start the first command in the DO phase */
  result = imap_select(conn);
  if(result)
    return result;

  /* run the state-machine */
  if(conn->data->state.used_interface == Curl_if_multi)
    result = imap_multi_statemach(conn, dophase_done);
  else {
    result = imap_easy_statemach(conn);
    *dophase_done = TRUE; /* with the easy interface we are done here */
  }
  *connected = conn->bits.tcpconnect[FIRSTSOCKET];

  if(*dophase_done)
    DEBUGF(infof(conn->data, "DO phase is complete\n"));

  return result;
}

func_before: CURLcode imap_perform(struct connectdata *conn,
                     bool *connected,  /* connect status after PASV / PORT */
                     bool *dophase_done)
{
  /* this is IMAP and no proxy */
  CURLcode result=CURLE_OK;

  DEBUGF(infof(conn->data, "DO phase starts\n"));

  if(conn->data->set.opt_no_body) {
    /* requested no body means no transfer... */
    struct FTP *imap = conn->data->state.proto.imap;
    imap->transfer = FTPTRANSFER_INFO;
  }

  *dophase_done = FALSE; /* not done yet */

  /* start the first command in the DO phase */
  result = imap_select(conn);
  if(result)
    return result;

  /* run the state-machine */
  if(conn->data->state.used_interface == Curl_if_multi)
    result = imap_multi_statemach(conn, dophase_done);
  else {
    result = imap_easy_statemach(conn);
    *dophase_done = TRUE; /* with the easy interface we are done here */
  }
  *connected = conn->bits.tcpconnect[FIRSTSOCKET];

  if(*dophase_done)
    DEBUGF(infof(conn->data, "DO phase is complete\n"));

  return result;
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
-  int len;
 
   if(!*path)
     path = "INBOX";
 
   /* url decode the path and use this mailbox */
-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
-  if(!imapc->mailbox)
-    return CURLE_OUT_OF_MEMORY;
-
-  return CURLE_OK;
+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
 
 /* call this when the DO phase has completed */
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: CURLcode imap_perform(struct connectdata *conn,
                     bool *connected,  /* connect status after PASV / PORT */
                     bool *dophase_done)
{
  /* this is IMAP and no proxy */
  CURLcode result=CURLE_OK;

  DEBUGF(infof(conn->data, "DO phase starts\n"));

  if(conn->data->set.opt_no_body) {
    /* requested no body means no transfer... */
    struct FTP *imap = conn->data->state.proto.imap;
    imap->transfer = FTPTRANSFER_INFO;
  }

  *dophase_done = FALSE; /* not done yet */

  /* start the first command in the DO phase */
  result = imap_select(conn);
  if(result)
    return result;

  /* run the state-machine */
  if(conn->data->state.used_interface == Curl_if_multi)
    result = imap_multi_statemach(conn, dophase_done);
  else {
    result = imap_easy_statemach(conn);
    *dophase_done = TRUE; /* with the easy interface we are done here */
  }
  *connected = conn->bits.tcpconnect[FIRSTSOCKET];

  if(*dophase_done)
    DEBUGF(infof(conn->data, "DO phase is complete\n"));

  return result;
}


========================================

Entry ID: 22091
: 22091
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/imap.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: CURLcode imap_regular_transfer(struct connectdata *conn,
                              bool *dophase_done)
{
  CURLcode result=CURLE_OK;
  bool connected=FALSE;
  struct SessionHandle *data = conn->data;
  data->req.size = -1; /* make sure this is unknown at this point */

  Curl_pgrsSetUploadCounter(data, 0);
  Curl_pgrsSetDownloadCounter(data, 0);
  Curl_pgrsSetUploadSize(data, 0);
  Curl_pgrsSetDownloadSize(data, 0);

  result = imap_perform(conn,
                        &connected, /* have we connected after PASV/PORT */
                        dophase_done); /* all commands in the DO-phase done? */

  if(CURLE_OK == result) {

    if(!*dophase_done)
      /* the DO phase has not completed yet */
      return CURLE_OK;

    result = imap_dophase_done(conn, connected);
    if(result)
      return result;
  }

  return result;
}

func_before: CURLcode imap_regular_transfer(struct connectdata *conn,
                              bool *dophase_done)
{
  CURLcode result=CURLE_OK;
  bool connected=FALSE;
  struct SessionHandle *data = conn->data;
  data->req.size = -1; /* make sure this is unknown at this point */

  Curl_pgrsSetUploadCounter(data, 0);
  Curl_pgrsSetDownloadCounter(data, 0);
  Curl_pgrsSetUploadSize(data, 0);
  Curl_pgrsSetDownloadSize(data, 0);

  result = imap_perform(conn,
                        &connected, /* have we connected after PASV/PORT */
                        dophase_done); /* all commands in the DO-phase done? */

  if(CURLE_OK == result) {

    if(!*dophase_done)
      /* the DO phase has not completed yet */
      return CURLE_OK;

    result = imap_dophase_done(conn, connected);
    if(result)
      return result;
  }

  return result;
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
-  int len;
 
   if(!*path)
     path = "INBOX";
 
   /* url decode the path and use this mailbox */
-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
-  if(!imapc->mailbox)
-    return CURLE_OUT_OF_MEMORY;
-
-  return CURLE_OK;
+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
 
 /* call this when the DO phase has completed */
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: CURLcode imap_regular_transfer(struct connectdata *conn,
                              bool *dophase_done)
{
  CURLcode result=CURLE_OK;
  bool connected=FALSE;
  struct SessionHandle *data = conn->data;
  data->req.size = -1; /* make sure this is unknown at this point */

  Curl_pgrsSetUploadCounter(data, 0);
  Curl_pgrsSetDownloadCounter(data, 0);
  Curl_pgrsSetUploadSize(data, 0);
  Curl_pgrsSetDownloadSize(data, 0);

  result = imap_perform(conn,
                        &connected, /* have we connected after PASV/PORT */
                        dophase_done); /* all commands in the DO-phase done? */

  if(CURLE_OK == result) {

    if(!*dophase_done)
      /* the DO phase has not completed yet */
      return CURLE_OK;

    result = imap_dophase_done(conn, connected);
    if(result)
      return result;
  }

  return result;
}


========================================

Entry ID: 22092
: 22092
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: Partial
CVE ID: CVE-2012-0036
CVE Page: https://www.cvedetails.com/cve/CVE-2012-0036/
CWE ID: CWE-89
Complexity: Low
Confidentiality: Partial
Integrity: Partial
Known Exploits: 
Publish Date: 2012-04-13
Score: 7.5
Summary: curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.
Update Date: 2018-01-09
Vulnerability Classification: Sql 
add_lines: 0
codeLink: https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238
commit_id: 75ca568fa1c19de4c5358fed246686de8467c238
commit_message: URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich
del_lines: 0
file_name: lib/imap.c
files_changed: {"sha": "0dd5a1d0a687194492b2c38b54007de3e0775530", "filename": "lib/escape.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -31,6 +31,7 @@\n #include \"urldata.h\"\n #include \"warnless.h\"\n #include \"non-ascii.h\"\n+#include \"escape.h\"\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free"}<_**next**_>{"sha": "4c7f84133b6c5677586fa1258c2a09d2ba8fef20", "filename": "lib/escape.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif"}<_**next**_>{"sha": "c6701417d0449bdf6280cb6f886e397b36198b19", "filename": "lib/imap.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "cc360b8b95e1b8df55d17180f892945578a10c6a", "filename": "lib/pop3.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */"}<_**next**_>{"sha": "553c697d063edb448bb7ac80c6d9bac5d1d12d8b", "filename": "lib/smtp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "raw_url": "https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c", "contents_url": "https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238", "patch": "@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */"}
func_after: static CURLcode imap_select(struct connectdata *conn)
{
  CURLcode result = CURLE_OK;
  struct imap_conn *imapc = &conn->proto.imapc;
  const char *str;

  str = getcmdid(conn);

  result = imapsendf(conn, str, "%s SELECT %s", str,
                     imapc->mailbox?imapc->mailbox:"");
  if(result)
    return result;

  state(conn, IMAP_SELECT);
  return result;
}

func_before: static CURLcode imap_select(struct connectdata *conn)
{
  CURLcode result = CURLE_OK;
  struct imap_conn *imapc = &conn->proto.imapc;
  const char *str;

  str = getcmdid(conn);

  result = imapsendf(conn, str, "%s SELECT %s", str,
                     imapc->mailbox?imapc->mailbox:"");
  if(result)
    return result;

  state(conn, IMAP_SELECT);
  return result;
}

lang: C
lines_after: 
lines_before: 
parentID: 
patch: @@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
-  int len;
 
   if(!*path)
     path = "INBOX";
 
   /* url decode the path and use this mailbox */
-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
-  if(!imapc->mailbox)
-    return CURLE_OUT_OF_MEMORY;
-
-  return CURLE_OK;
+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
 
 /* call this when the DO phase has completed */
project: curl
project_after: 75ca568fa1c19de4c5358fed246686de8467c238
project_before: db1a856b4f7cf6ae334fb0656b26a18eea317000
vul: 0
vul_func_with_fix: static CURLcode imap_select(struct connectdata *conn)
{
  CURLcode result = CURLE_OK;
  struct imap_conn *imapc = &conn->proto.imapc;
  const char *str;

  str = getcmdid(conn);

  result = imapsendf(conn, str, "%s SELECT %s", str,
                     imapc->mailbox?imapc->mailbox:"");
  if(result)
    return result;

  state(conn, IMAP_SELECT);
  return result;
}


========================================


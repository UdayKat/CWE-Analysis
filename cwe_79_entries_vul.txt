Entry ID: 180644
: 180644
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2015-8935
CVE Page: https://www.cvedetails.com/cve/CVE-2015-8935/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2016-08-07
Score: 4.3
Summary: The sapi_header_op function in main/SAPI.c in PHP before 5.4.38, 5.5.x before 5.5.22, and 5.6.x before 5.6.6 supports deprecated line folding without considering browser compatibility, which allows remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer by leveraging (1) %0A%20 or (2) %0D%0A%20 mishandling in the header function.
Update Date: 2018-01-04
Vulnerability Classification: XSS 
add_lines: 2
codeLink: https://github.com/php/php-src/commit/996faf964bba1aec06b153b370a7f20d3dd2bb8b?w=1
commit_id: 996faf964bba1aec06b153b370a7f20d3dd2bb8b?w=1
commit_message: Update header handling to RFC 7230
del_lines: 7
file_name: main/SAPI.c
files_changed: {"sha": "2cdde78a4a9140d98acf0e5683aaaaaf6213e063", "filename": "ext/standard/tests/general_functions/bug60227_2.phpt", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/php/php-src/blob/996faf964bba1aec06b153b370a7f20d3dd2bb8b/ext/standard/tests/general_functions/bug60227_2.phpt", "raw_url": "https://github.com/php/php-src/raw/996faf964bba1aec06b153b370a7f20d3dd2bb8b/ext/standard/tests/general_functions/bug60227_2.phpt", "contents_url": "https://api.github.com/repos/php/php-src/contents/ext/standard/tests/general_functions/bug60227_2.phpt?ref=996faf964bba1aec06b153b370a7f20d3dd2bb8b", "patch": "@@ -1,14 +1,15 @@\n --TEST--\n Bug #60227 (header() cannot detect the multi-line header with CR), \\r before \\n\n+--INI--\n+expose_php=0\n --FILE--\n <?php\n header(\"X-foo: e\\n foo\");\n-header(\"X-Foo6: e\\rSet-Cookie: ID=123\\n d\");\n echo 'foo';\n ?>\n --EXPECTF--\n+\n Warning: Header may not contain more than a single header, new line detected in %s on line %d\n foo\n --EXPECTHEADERS--\n-X-foo: e\n-foo\n+Content-type: text/html; charset=UTF-8"}<_**next**_>{"sha": "8246f1743835c307beb889604bc1f3ba76d0fb4a", "filename": "ext/standard/tests/general_functions/bug60227_3.phpt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/php/php-src/blob/996faf964bba1aec06b153b370a7f20d3dd2bb8b/ext/standard/tests/general_functions/bug60227_3.phpt", "raw_url": "https://github.com/php/php-src/raw/996faf964bba1aec06b153b370a7f20d3dd2bb8b/ext/standard/tests/general_functions/bug60227_3.phpt", "contents_url": "https://api.github.com/repos/php/php-src/contents/ext/standard/tests/general_functions/bug60227_3.phpt?ref=996faf964bba1aec06b153b370a7f20d3dd2bb8b", "patch": "@@ -1,14 +1,14 @@\n --TEST--\n Bug #60227 (header() cannot detect the multi-line header with CR), \\0 before \\n\n+--INI--\n+expose_php=0\n --FILE--\n <?php\n-header(\"X-foo: e\\n foo\");\n header(\"X-Foo6: e\\0Set-Cookie: ID=\\n123\\n d\");\n echo 'foo';\n ?>\n --EXPECTF--\n Warning: Header may not contain NUL bytes in %s on line %d\n foo\n --EXPECTHEADERS--\n-X-foo: e\n-foo\n+Content-type: text/html; charset=UTF-8"}<_**next**_>{"sha": "20dba1a26568e55ad47a0af4e91efe9f59a417ba", "filename": "ext/standard/tests/general_functions/bug60227_4.phpt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/php/php-src/blob/996faf964bba1aec06b153b370a7f20d3dd2bb8b/ext/standard/tests/general_functions/bug60227_4.phpt", "raw_url": "https://github.com/php/php-src/raw/996faf964bba1aec06b153b370a7f20d3dd2bb8b/ext/standard/tests/general_functions/bug60227_4.phpt", "contents_url": "https://api.github.com/repos/php/php-src/contents/ext/standard/tests/general_functions/bug60227_4.phpt?ref=996faf964bba1aec06b153b370a7f20d3dd2bb8b", "patch": "@@ -1,14 +1,14 @@\n --TEST--\n Bug #60227 (header() cannot detect the multi-line header with CR), CRLF\n+--INI--\n+expose_php=0\n --FILE--\n <?php\n-header(\"X-foo: e\\r\\n foo\");\n header(\"X-foo: e\\r\\nfoo\");\n echo 'foo';\n ?>\n --EXPECTF--\n Warning: Header may not contain more than a single header, new line detected in %s on line %d\n foo\n --EXPECTHEADERS--\n-X-foo: e\n- foo\n+Content-type: text/html; charset=UTF-8"}<_**next**_>{"sha": "0dd0b55df548f59b60fad2cd0d5733665fe1b123", "filename": "main/SAPI.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/php/php-src/blob/996faf964bba1aec06b153b370a7f20d3dd2bb8b/main/SAPI.c", "raw_url": "https://github.com/php/php-src/raw/996faf964bba1aec06b153b370a7f20d3dd2bb8b/main/SAPI.c", "contents_url": "https://api.github.com/repos/php/php-src/contents/main/SAPI.c?ref=996faf964bba1aec06b153b370a7f20d3dd2bb8b", "patch": "@@ -743,13 +743,8 @@ SAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)\n \t\t/* new line/NUL character safety check */\n \t\tint i;\n \t\tfor (i = 0; i < header_line_len; i++) {\n-\t\t\t/* RFC 2616 allows new lines if followed by SP or HT */\n-\t\t\tint illegal_break =\n-\t\t\t\t\t(header_line[i+1] != ' ' && header_line[i+1] != '\\t')\n-\t\t\t\t\t&& (\n-\t\t\t\t\t\theader_line[i] == '\\n'\n-\t\t\t\t\t\t|| (header_line[i] == '\\r' && header_line[i+1] != '\\n'));\n-\t\t\tif (illegal_break) {\n+\t\t\t/* RFC 7230 ch. 3.2.4 deprecates folding support */\n+\t\t\tif (header_line[i] == '\\n' || header_line[i] == '\\r') {\n \t\t\t\tefree(header_line);\n \t\t\t\tsapi_module.sapi_error(E_WARNING, \"Header may not contain \"\n \t\t\t\t\t\t\"more than a single header, new line detected\");"}
func_after: SAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)
{
	sapi_header_struct sapi_header;
	char *colon_offset;
	char *header_line;
	uint header_line_len;
	int http_response_code;

	if (SG(headers_sent) && !SG(request_info).no_headers) {
		const char *output_start_filename = php_output_get_start_filename(TSRMLS_C);
		int output_start_lineno = php_output_get_start_lineno(TSRMLS_C);

		if (output_start_filename) {
			sapi_module.sapi_error(E_WARNING, "Cannot modify header information - headers already sent by (output started at %s:%d)",
				output_start_filename, output_start_lineno);
		} else {
			sapi_module.sapi_error(E_WARNING, "Cannot modify header information - headers already sent");
		}
		return FAILURE;
	}

	switch (op) {
		case SAPI_HEADER_SET_STATUS:
			sapi_update_response_code((int)(zend_intptr_t) arg TSRMLS_CC);
			return SUCCESS;

		case SAPI_HEADER_ADD:
		case SAPI_HEADER_REPLACE:
		case SAPI_HEADER_DELETE: {
				sapi_header_line *p = arg;

				if (!p->line || !p->line_len) {
					return FAILURE;
				}
				header_line = p->line;
				header_line_len = p->line_len;
				http_response_code = p->response_code;
				break;
			}

		case SAPI_HEADER_DELETE_ALL:
			if (sapi_module.header_handler) {
				sapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);
			}
			zend_llist_clean(&SG(sapi_headers).headers);
			return SUCCESS;

		default:
			return FAILURE;
	}

	header_line = estrndup(header_line, header_line_len);

	/* cut off trailing spaces, linefeeds and carriage-returns */
	if (header_line_len && isspace(header_line[header_line_len-1])) {
		do {
			header_line_len--;
		} while(header_line_len && isspace(header_line[header_line_len-1]));
		header_line[header_line_len]='\0';
	}
	
	if (op == SAPI_HEADER_DELETE) {
		if (strchr(header_line, ':')) {
			efree(header_line);
			sapi_module.sapi_error(E_WARNING, "Header to delete may not contain colon.");
			return FAILURE;
		}
		if (sapi_module.header_handler) {
			sapi_header.header = header_line;
			sapi_header.header_len = header_line_len;
			sapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);
		}
		sapi_remove_header(&SG(sapi_headers).headers, header_line, header_line_len);
		efree(header_line);
		return SUCCESS;
	} else {
 		/* new line/NUL character safety check */
 		int i;
 		for (i = 0; i < header_line_len; i++) {
			/* RFC 7230 ch. 3.2.4 deprecates folding support */
			if (header_line[i] == '\n' || header_line[i] == '\r') {
 				efree(header_line);
 				sapi_module.sapi_error(E_WARNING, "Header may not contain "
 						"more than a single header, new line detected");
				return FAILURE;
			}
			if (header_line[i] == '\0') {
				efree(header_line);
				sapi_module.sapi_error(E_WARNING, "Header may not contain NUL bytes");
				return FAILURE;
			}
		}
	}

	sapi_header.header = header_line;
	sapi_header.header_len = header_line_len;

	/* Check the header for a few cases that we have special support for in SAPI */
	if (header_line_len>=5 
		&& !strncasecmp(header_line, "HTTP/", 5)) {
		/* filter out the response code */
		sapi_update_response_code(sapi_extract_response_code(header_line) TSRMLS_CC);
		/* sapi_update_response_code doesn't free the status line if the code didn't change */
		if (SG(sapi_headers).http_status_line) {
			efree(SG(sapi_headers).http_status_line);
		}
		SG(sapi_headers).http_status_line = header_line;
		return SUCCESS;
	} else {
		colon_offset = strchr(header_line, ':');
		if (colon_offset) {
			*colon_offset = 0;
			if (!STRCASECMP(header_line, "Content-Type")) {
				char *ptr = colon_offset+1, *mimetype = NULL, *newheader;
				size_t len = header_line_len - (ptr - header_line), newlen;
				while (*ptr == ' ') {
					ptr++;
					len--;
				}

				/* Disable possible output compression for images */
				if (!strncmp(ptr, "image/", sizeof("image/")-1)) {
					zend_alter_ini_entry("zlib.output_compression", sizeof("zlib.output_compression"), "0", sizeof("0") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
				}

				mimetype = estrdup(ptr);
				newlen = sapi_apply_default_charset(&mimetype, len TSRMLS_CC);
				if (!SG(sapi_headers).mimetype){
					SG(sapi_headers).mimetype = estrdup(mimetype);
				}

				if (newlen != 0) {
					newlen += sizeof("Content-type: ");
					newheader = emalloc(newlen);
					PHP_STRLCPY(newheader, "Content-type: ", newlen, sizeof("Content-type: ")-1);
					strlcat(newheader, mimetype, newlen);
					sapi_header.header = newheader;
					sapi_header.header_len = newlen - 1;
					efree(header_line);
				}
				efree(mimetype);
				SG(sapi_headers).send_default_content_type = 0;
			} else if (!STRCASECMP(header_line, "Content-Length")) {
				/* Script is setting Content-length. The script cannot reasonably
				 * know the size of the message body after compression, so it's best
				 * do disable compression altogether. This contributes to making scripts
				 * portable between setups that have and don't have zlib compression
				 * enabled globally. See req #44164 */
				zend_alter_ini_entry("zlib.output_compression", sizeof("zlib.output_compression"),
					"0", sizeof("0") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
			} else if (!STRCASECMP(header_line, "Location")) {
				if ((SG(sapi_headers).http_response_code < 300 ||
					SG(sapi_headers).http_response_code > 399) &&
					SG(sapi_headers).http_response_code != 201) {
					/* Return a Found Redirect if one is not already specified */
					if (http_response_code) { /* user specified redirect code */
						sapi_update_response_code(http_response_code TSRMLS_CC);
					} else if (SG(request_info).proto_num > 1000 && 
					   SG(request_info).request_method && 
					   strcmp(SG(request_info).request_method, "HEAD") &&
					   strcmp(SG(request_info).request_method, "GET")) {
						sapi_update_response_code(303 TSRMLS_CC);
					} else {
						sapi_update_response_code(302 TSRMLS_CC);
					}
				}
			} else if (!STRCASECMP(header_line, "WWW-Authenticate")) { /* HTTP Authentication */
				sapi_update_response_code(401 TSRMLS_CC); /* authentication-required */
			}
			if (sapi_header.header==header_line) {
				*colon_offset = ':';
			}
		}
	}
	if (http_response_code) {
		sapi_update_response_code(http_response_code TSRMLS_CC);
	}
	sapi_header_add_op(op, &sapi_header TSRMLS_CC);
	return SUCCESS;
}

func_before: SAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)
{
	sapi_header_struct sapi_header;
	char *colon_offset;
	char *header_line;
	uint header_line_len;
	int http_response_code;

	if (SG(headers_sent) && !SG(request_info).no_headers) {
		const char *output_start_filename = php_output_get_start_filename(TSRMLS_C);
		int output_start_lineno = php_output_get_start_lineno(TSRMLS_C);

		if (output_start_filename) {
			sapi_module.sapi_error(E_WARNING, "Cannot modify header information - headers already sent by (output started at %s:%d)",
				output_start_filename, output_start_lineno);
		} else {
			sapi_module.sapi_error(E_WARNING, "Cannot modify header information - headers already sent");
		}
		return FAILURE;
	}

	switch (op) {
		case SAPI_HEADER_SET_STATUS:
			sapi_update_response_code((int)(zend_intptr_t) arg TSRMLS_CC);
			return SUCCESS;

		case SAPI_HEADER_ADD:
		case SAPI_HEADER_REPLACE:
		case SAPI_HEADER_DELETE: {
				sapi_header_line *p = arg;

				if (!p->line || !p->line_len) {
					return FAILURE;
				}
				header_line = p->line;
				header_line_len = p->line_len;
				http_response_code = p->response_code;
				break;
			}

		case SAPI_HEADER_DELETE_ALL:
			if (sapi_module.header_handler) {
				sapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);
			}
			zend_llist_clean(&SG(sapi_headers).headers);
			return SUCCESS;

		default:
			return FAILURE;
	}

	header_line = estrndup(header_line, header_line_len);

	/* cut off trailing spaces, linefeeds and carriage-returns */
	if (header_line_len && isspace(header_line[header_line_len-1])) {
		do {
			header_line_len--;
		} while(header_line_len && isspace(header_line[header_line_len-1]));
		header_line[header_line_len]='\0';
	}
	
	if (op == SAPI_HEADER_DELETE) {
		if (strchr(header_line, ':')) {
			efree(header_line);
			sapi_module.sapi_error(E_WARNING, "Header to delete may not contain colon.");
			return FAILURE;
		}
		if (sapi_module.header_handler) {
			sapi_header.header = header_line;
			sapi_header.header_len = header_line_len;
			sapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);
		}
		sapi_remove_header(&SG(sapi_headers).headers, header_line, header_line_len);
		efree(header_line);
		return SUCCESS;
	} else {
 		/* new line/NUL character safety check */
 		int i;
 		for (i = 0; i < header_line_len; i++) {
			/* RFC 2616 allows new lines if followed by SP or HT */
			int illegal_break =
					(header_line[i+1] != ' ' && header_line[i+1] != '\t')
					&& (
						header_line[i] == '\n'
						|| (header_line[i] == '\r' && header_line[i+1] != '\n'));
			if (illegal_break) {
 				efree(header_line);
 				sapi_module.sapi_error(E_WARNING, "Header may not contain "
 						"more than a single header, new line detected");
				return FAILURE;
			}
			if (header_line[i] == '\0') {
				efree(header_line);
				sapi_module.sapi_error(E_WARNING, "Header may not contain NUL bytes");
				return FAILURE;
			}
		}
	}

	sapi_header.header = header_line;
	sapi_header.header_len = header_line_len;

	/* Check the header for a few cases that we have special support for in SAPI */
	if (header_line_len>=5 
		&& !strncasecmp(header_line, "HTTP/", 5)) {
		/* filter out the response code */
		sapi_update_response_code(sapi_extract_response_code(header_line) TSRMLS_CC);
		/* sapi_update_response_code doesn't free the status line if the code didn't change */
		if (SG(sapi_headers).http_status_line) {
			efree(SG(sapi_headers).http_status_line);
		}
		SG(sapi_headers).http_status_line = header_line;
		return SUCCESS;
	} else {
		colon_offset = strchr(header_line, ':');
		if (colon_offset) {
			*colon_offset = 0;
			if (!STRCASECMP(header_line, "Content-Type")) {
				char *ptr = colon_offset+1, *mimetype = NULL, *newheader;
				size_t len = header_line_len - (ptr - header_line), newlen;
				while (*ptr == ' ') {
					ptr++;
					len--;
				}

				/* Disable possible output compression for images */
				if (!strncmp(ptr, "image/", sizeof("image/")-1)) {
					zend_alter_ini_entry("zlib.output_compression", sizeof("zlib.output_compression"), "0", sizeof("0") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
				}

				mimetype = estrdup(ptr);
				newlen = sapi_apply_default_charset(&mimetype, len TSRMLS_CC);
				if (!SG(sapi_headers).mimetype){
					SG(sapi_headers).mimetype = estrdup(mimetype);
				}

				if (newlen != 0) {
					newlen += sizeof("Content-type: ");
					newheader = emalloc(newlen);
					PHP_STRLCPY(newheader, "Content-type: ", newlen, sizeof("Content-type: ")-1);
					strlcat(newheader, mimetype, newlen);
					sapi_header.header = newheader;
					sapi_header.header_len = newlen - 1;
					efree(header_line);
				}
				efree(mimetype);
				SG(sapi_headers).send_default_content_type = 0;
			} else if (!STRCASECMP(header_line, "Content-Length")) {
				/* Script is setting Content-length. The script cannot reasonably
				 * know the size of the message body after compression, so it's best
				 * do disable compression altogether. This contributes to making scripts
				 * portable between setups that have and don't have zlib compression
				 * enabled globally. See req #44164 */
				zend_alter_ini_entry("zlib.output_compression", sizeof("zlib.output_compression"),
					"0", sizeof("0") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
			} else if (!STRCASECMP(header_line, "Location")) {
				if ((SG(sapi_headers).http_response_code < 300 ||
					SG(sapi_headers).http_response_code > 399) &&
					SG(sapi_headers).http_response_code != 201) {
					/* Return a Found Redirect if one is not already specified */
					if (http_response_code) { /* user specified redirect code */
						sapi_update_response_code(http_response_code TSRMLS_CC);
					} else if (SG(request_info).proto_num > 1000 && 
					   SG(request_info).request_method && 
					   strcmp(SG(request_info).request_method, "HEAD") &&
					   strcmp(SG(request_info).request_method, "GET")) {
						sapi_update_response_code(303 TSRMLS_CC);
					} else {
						sapi_update_response_code(302 TSRMLS_CC);
					}
				}
			} else if (!STRCASECMP(header_line, "WWW-Authenticate")) { /* HTTP Authentication */
				sapi_update_response_code(401 TSRMLS_CC); /* authentication-required */
			}
			if (sapi_header.header==header_line) {
				*colon_offset = ':';
			}
		}
	}
	if (http_response_code) {
		sapi_update_response_code(http_response_code TSRMLS_CC);
	}
	sapi_header_add_op(op, &sapi_header TSRMLS_CC);
	return SUCCESS;
}

lang: C
lines_after: 			/* RFC 7230 ch. 3.2.4 deprecates folding support */
			if (header_line[i] == '\n' || header_line[i] == '\r') {

lines_before: 			/* RFC 2616 allows new lines if followed by SP or HT */
			int illegal_break =
					(header_line[i+1] != ' ' && header_line[i+1] != '\t')
					&& (
						header_line[i] == '\n'
						|| (header_line[i] == '\r' && header_line[i+1] != '\n'));
			if (illegal_break) {

parentID: 
patch: @@ -743,13 +743,8 @@ SAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)
 		/* new line/NUL character safety check */
 		int i;
 		for (i = 0; i < header_line_len; i++) {
-			/* RFC 2616 allows new lines if followed by SP or HT */
-			int illegal_break =
-					(header_line[i+1] != ' ' && header_line[i+1] != '\t')
-					&& (
-						header_line[i] == '\n'
-						|| (header_line[i] == '\r' && header_line[i+1] != '\n'));
-			if (illegal_break) {
+			/* RFC 7230 ch. 3.2.4 deprecates folding support */
+			if (header_line[i] == '\n' || header_line[i] == '\r') {
 				efree(header_line);
 				sapi_module.sapi_error(E_WARNING, "Header may not contain "
 						"more than a single header, new line detected");
project: php-src
project_after: 996faf964bba1aec06b153b370a7f20d3dd2bb8b?w=1
project_before: d8bc34942d4f94cecdcbc63aa0772c5717525279
vul: 1
vul_func_with_fix: SAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)
{
	sapi_header_struct sapi_header;
	char *colon_offset;
	char *header_line;
	uint header_line_len;
	int http_response_code;

	if (SG(headers_sent) && !SG(request_info).no_headers) {
		const char *output_start_filename = php_output_get_start_filename(TSRMLS_C);
		int output_start_lineno = php_output_get_start_lineno(TSRMLS_C);

		if (output_start_filename) {
			sapi_module.sapi_error(E_WARNING, "Cannot modify header information - headers already sent by (output started at %s:%d)",
				output_start_filename, output_start_lineno);
		} else {
			sapi_module.sapi_error(E_WARNING, "Cannot modify header information - headers already sent");
		}
		return FAILURE;
	}

	switch (op) {
		case SAPI_HEADER_SET_STATUS:
			sapi_update_response_code((int)(zend_intptr_t) arg TSRMLS_CC);
			return SUCCESS;

		case SAPI_HEADER_ADD:
		case SAPI_HEADER_REPLACE:
		case SAPI_HEADER_DELETE: {
				sapi_header_line *p = arg;

				if (!p->line || !p->line_len) {
					return FAILURE;
				}
				header_line = p->line;
				header_line_len = p->line_len;
				http_response_code = p->response_code;
				break;
			}

		case SAPI_HEADER_DELETE_ALL:
			if (sapi_module.header_handler) {
				sapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);
			}
			zend_llist_clean(&SG(sapi_headers).headers);
			return SUCCESS;

		default:
			return FAILURE;
	}

	header_line = estrndup(header_line, header_line_len);

	/* cut off trailing spaces, linefeeds and carriage-returns */
	if (header_line_len && isspace(header_line[header_line_len-1])) {
		do {
			header_line_len--;
		} while(header_line_len && isspace(header_line[header_line_len-1]));
		header_line[header_line_len]='\0';
	}
	
	if (op == SAPI_HEADER_DELETE) {
		if (strchr(header_line, ':')) {
			efree(header_line);
			sapi_module.sapi_error(E_WARNING, "Header to delete may not contain colon.");
			return FAILURE;
		}
		if (sapi_module.header_handler) {
			sapi_header.header = header_line;
			sapi_header.header_len = header_line_len;
			sapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);
		}
		sapi_remove_header(&SG(sapi_headers).headers, header_line, header_line_len);
		efree(header_line);
		return SUCCESS;
	} else {
 		/* new line/NUL character safety check */
 		int i;
 		for (i = 0; i < header_line_len; i++) {
//flaw_line_below:
			/* RFC 2616 allows new lines if followed by SP or HT */
//flaw_line_below:
			int illegal_break =
//flaw_line_below:
					(header_line[i+1] != ' ' && header_line[i+1] != '\t')
//flaw_line_below:
					&& (
//flaw_line_below:
						header_line[i] == '\n'
//flaw_line_below:
						|| (header_line[i] == '\r' && header_line[i+1] != '\n'));
//flaw_line_below:
			if (illegal_break) {
//fix_flaw_line_below:
//			/* RFC 7230 ch. 3.2.4 deprecates folding support */
//fix_flaw_line_below:
//			if (header_line[i] == '\n' || header_line[i] == '\r') {
 				efree(header_line);
 				sapi_module.sapi_error(E_WARNING, "Header may not contain "
 						"more than a single header, new line detected");
				return FAILURE;
			}
			if (header_line[i] == '\0') {
				efree(header_line);
				sapi_module.sapi_error(E_WARNING, "Header may not contain NUL bytes");
				return FAILURE;
			}
		}
	}

	sapi_header.header = header_line;
	sapi_header.header_len = header_line_len;

	/* Check the header for a few cases that we have special support for in SAPI */
	if (header_line_len>=5 
		&& !strncasecmp(header_line, "HTTP/", 5)) {
		/* filter out the response code */
		sapi_update_response_code(sapi_extract_response_code(header_line) TSRMLS_CC);
		/* sapi_update_response_code doesn't free the status line if the code didn't change */
		if (SG(sapi_headers).http_status_line) {
			efree(SG(sapi_headers).http_status_line);
		}
		SG(sapi_headers).http_status_line = header_line;
		return SUCCESS;
	} else {
		colon_offset = strchr(header_line, ':');
		if (colon_offset) {
			*colon_offset = 0;
			if (!STRCASECMP(header_line, "Content-Type")) {
				char *ptr = colon_offset+1, *mimetype = NULL, *newheader;
				size_t len = header_line_len - (ptr - header_line), newlen;
				while (*ptr == ' ') {
					ptr++;
					len--;
				}

				/* Disable possible output compression for images */
				if (!strncmp(ptr, "image/", sizeof("image/")-1)) {
					zend_alter_ini_entry("zlib.output_compression", sizeof("zlib.output_compression"), "0", sizeof("0") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
				}

				mimetype = estrdup(ptr);
				newlen = sapi_apply_default_charset(&mimetype, len TSRMLS_CC);
				if (!SG(sapi_headers).mimetype){
					SG(sapi_headers).mimetype = estrdup(mimetype);
				}

				if (newlen != 0) {
					newlen += sizeof("Content-type: ");
					newheader = emalloc(newlen);
					PHP_STRLCPY(newheader, "Content-type: ", newlen, sizeof("Content-type: ")-1);
					strlcat(newheader, mimetype, newlen);
					sapi_header.header = newheader;
					sapi_header.header_len = newlen - 1;
					efree(header_line);
				}
				efree(mimetype);
				SG(sapi_headers).send_default_content_type = 0;
			} else if (!STRCASECMP(header_line, "Content-Length")) {
				/* Script is setting Content-length. The script cannot reasonably
				 * know the size of the message body after compression, so it's best
				 * do disable compression altogether. This contributes to making scripts
				 * portable between setups that have and don't have zlib compression
				 * enabled globally. See req #44164 */
				zend_alter_ini_entry("zlib.output_compression", sizeof("zlib.output_compression"),
					"0", sizeof("0") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
			} else if (!STRCASECMP(header_line, "Location")) {
				if ((SG(sapi_headers).http_response_code < 300 ||
					SG(sapi_headers).http_response_code > 399) &&
					SG(sapi_headers).http_response_code != 201) {
					/* Return a Found Redirect if one is not already specified */
					if (http_response_code) { /* user specified redirect code */
						sapi_update_response_code(http_response_code TSRMLS_CC);
					} else if (SG(request_info).proto_num > 1000 && 
					   SG(request_info).request_method && 
					   strcmp(SG(request_info).request_method, "HEAD") &&
					   strcmp(SG(request_info).request_method, "GET")) {
						sapi_update_response_code(303 TSRMLS_CC);
					} else {
						sapi_update_response_code(302 TSRMLS_CC);
					}
				}
			} else if (!STRCASECMP(header_line, "WWW-Authenticate")) { /* HTTP Authentication */
				sapi_update_response_code(401 TSRMLS_CC); /* authentication-required */
			}
			if (sapi_header.header==header_line) {
				*colon_offset = ':';
			}
		}
	}
	if (http_response_code) {
		sapi_update_response_code(http_response_code TSRMLS_CC);
	}
	sapi_header_add_op(op, &sapi_header TSRMLS_CC);
	return SUCCESS;
}


========================================

Entry ID: 182200
: 182200
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2018-17082
CVE Page: https://www.cvedetails.com/cve/CVE-2018-17082/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2018-09-16
Score: 4.3
Summary: The Apache2 component in PHP before 5.6.38, 7.0.x before 7.0.32, 7.1.x before 7.1.22, and 7.2.x before 7.2.10 allows XSS via the body of a *Transfer-Encoding: chunked* request, because the bucket brigade is mishandled in the php_handler function in sapi/apache2handler/sapi_apache2.c.
Update Date: 2019-08-19
Vulnerability Classification: XSS 
add_lines: 1
codeLink: https://github.com/php/php-src/commit/23b057742e3cf199612fa8050ae86cae675e214e
commit_id: 23b057742e3cf199612fa8050ae86cae675e214e
commit_message: Fix for bug #76582

The brigade seems to end up in a messed up state if something fails
in shutdown, so we clean it up.
del_lines: 0
file_name: sapi/apache2handler/sapi_apache2.c
files_changed: {"sha": "0ebca9bca863909aef3fd3417bb3baad1605df34", "filename": "sapi/apache2handler/sapi_apache2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/php/php-src/blob/23b057742e3cf199612fa8050ae86cae675e214e/sapi/apache2handler/sapi_apache2.c", "raw_url": "https://github.com/php/php-src/raw/23b057742e3cf199612fa8050ae86cae675e214e/sapi/apache2handler/sapi_apache2.c", "contents_url": "https://api.github.com/repos/php/php-src/contents/sapi/apache2handler/sapi_apache2.c?ref=23b057742e3cf199612fa8050ae86cae675e214e", "patch": "@@ -678,6 +678,7 @@ zend_first_try {\n \tif (!parent_req) {\n \t\tphp_apache_request_dtor(r TSRMLS_CC);\n \t\tctx->request_processed = 1;\n+\t\tapr_brigade_cleanup(brigade);\n \t\tbucket = apr_bucket_eos_create(r->connection->bucket_alloc);\n \t\tAPR_BRIGADE_INSERT_TAIL(brigade, bucket);\n "}
func_after: static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, "INCLUDED"))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, "text/html") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex("script '%s' not found or unable to stat", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex("attempt to invoke directory '%s' as script", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, "INCLUDED")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, "mod_php_memory_usage",
			apr_psprintf(ctx->r->pool, "%" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}

func_before: static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, "INCLUDED"))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, "text/html") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex("script '%s' not found or unable to stat", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex("attempt to invoke directory '%s' as script", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, "INCLUDED")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, "mod_php_memory_usage",
			apr_psprintf(ctx->r->pool, "%" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}

lang: C
lines_after: 		apr_brigade_cleanup(brigade);

lines_before: 
parentID: 
patch: @@ -678,6 +678,7 @@ zend_first_try {
 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
+		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
project: php-src
project_after: 23b057742e3cf199612fa8050ae86cae675e214e
project_before: 1ba3314335b8bb7c86c24443588d5ef9c55d4a44
vul: 1
vul_func_with_fix: static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, "INCLUDED"))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, "text/html") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex("script '%s' not found or unable to stat", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex("attempt to invoke directory '%s' as script", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, "INCLUDED")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, "mod_php_memory_usage",
			apr_psprintf(ctx->r->pool, "%" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
//fix_flaw_line_below:
//		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 
		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
} zend_end_try();
		}
		apr_brigade_cleanup(brigade);
		apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
	} else {
		ctx->r = parent_req;
	}

	return OK;
}


========================================

Entry ID: 184283
: 184283
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2012-2889
CVE Page: https://www.cvedetails.com/cve/CVE-2012-2889/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2012-09-26
Score: 4.3
Summary: Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*
Update Date: 2017-09-18
Vulnerability Classification: XSS 
add_lines: 1
codeLink: https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_id: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_message: [views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98
del_lines: 0
file_name: chrome/browser/ui/views/extensions/shell_window_views.cc
files_changed: {"sha": "5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b", "filename": "chrome/browser/ui/views/extensions/shell_window_views.cc", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "raw_url": "https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5", "patch": "@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \"browser/ui/views/extensions/ShellWindowFrameView\";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }"}
func_after:  void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }

func_before:  void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
   if (sender == close_button_)
     frame_->Close();
 }

lang: C
lines_after:   DCHECK(!is_frameless_);

lines_before: 
parentID: 
patch: @@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     "browser/ui/views/extensions/ShellWindowFrameView";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }
project: Chrome
project_after: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
project_before: d7ddf81573776614bf124ce1845b99f9115fb64b
vul: 1
vul_func_with_fix:  void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
//fix_flaw_line_below:
//  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }


========================================

Entry ID: 184284
: 184284
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2012-2889
CVE Page: https://www.cvedetails.com/cve/CVE-2012-2889/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2012-09-26
Score: 4.3
Summary: Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*
Update Date: 2017-09-18
Vulnerability Classification: XSS 
add_lines: 2
codeLink: https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_id: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_message: [views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98
del_lines: 1
file_name: chrome/browser/ui/views/extensions/shell_window_views.cc
files_changed: {"sha": "5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b", "filename": "chrome/browser/ui/views/extensions/shell_window_views.cc", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "raw_url": "https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5", "patch": "@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \"browser/ui/views/extensions/ShellWindowFrameView\";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }"}
func_after:  views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
  ShellWindowFrameView* frame_view =
      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }

func_before:  views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
   frame_view->Init(window_);
   return frame_view;
 }

lang: C
lines_after:   ShellWindowFrameView* frame_view =
      new ShellWindowFrameView(use_custom_frame_);

lines_before:   ShellWindowFrameView* frame_view = new ShellWindowFrameView();

parentID: 
patch: @@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     "browser/ui/views/extensions/ShellWindowFrameView";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }
project: Chrome
project_after: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
project_before: d7ddf81573776614bf124ce1845b99f9115fb64b
vul: 1
vul_func_with_fix:  views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
//flaw_line_below:
  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
//fix_flaw_line_below:
//  ShellWindowFrameView* frame_view =
//fix_flaw_line_below:
//      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }


========================================

Entry ID: 184285
: 184285
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2012-2889
CVE Page: https://www.cvedetails.com/cve/CVE-2012-2889/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2012-09-26
Score: 4.3
Summary: Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*
Update Date: 2017-09-18
Vulnerability Classification: XSS 
add_lines: 1
codeLink: https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_id: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_message: [views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98
del_lines: 1
file_name: chrome/browser/ui/views/extensions/shell_window_views.cc
files_changed: {"sha": "5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b", "filename": "chrome/browser/ui/views/extensions/shell_window_views.cc", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "raw_url": "https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5", "patch": "@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \"browser/ui/views/extensions/ShellWindowFrameView\";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }"}
func_after:  gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }

func_before:  gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
  if (frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }

lang: C
lines_after:   if (is_frameless_ || frame_->IsFullscreen())

lines_before:   if (frame_->IsFullscreen())

parentID: 
patch: @@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     "browser/ui/views/extensions/ShellWindowFrameView";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }
project: Chrome
project_after: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
project_before: d7ddf81573776614bf124ce1845b99f9115fb64b
vul: 1
vul_func_with_fix:  gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
//flaw_line_below:
  if (frame_->IsFullscreen())
//fix_flaw_line_below:
//  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }


========================================

Entry ID: 184286
: 184286
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2012-2889
CVE Page: https://www.cvedetails.com/cve/CVE-2012-2889/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2012-09-26
Score: 4.3
Summary: Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*
Update Date: 2017-09-18
Vulnerability Classification: XSS 
add_lines: 3
codeLink: https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_id: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_message: [views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98
del_lines: 0
file_name: chrome/browser/ui/views/extensions/shell_window_views.cc
files_changed: {"sha": "5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b", "filename": "chrome/browser/ui/views/extensions/shell_window_views.cc", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "raw_url": "https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5", "patch": "@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \"browser/ui/views/extensions/ShellWindowFrameView\";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }"}
func_after:  gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
  if (is_frameless_)
    return max_size;

   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
  }
  return max_size;
}

func_before:  gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
  }
  return max_size;
}

lang: C
lines_after:   if (is_frameless_)
    return max_size;


lines_before: 
parentID: 
patch: @@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     "browser/ui/views/extensions/ShellWindowFrameView";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }
project: Chrome
project_after: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
project_before: d7ddf81573776614bf124ce1845b99f9115fb64b
vul: 1
vul_func_with_fix:  gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
//fix_flaw_line_below:
//  if (is_frameless_)
//fix_flaw_line_below:
//    return max_size;
//fix_flaw_line_below:
//
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
  }
  return max_size;
}


========================================

Entry ID: 184287
: 184287
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2012-2889
CVE Page: https://www.cvedetails.com/cve/CVE-2012-2889/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2012-09-26
Score: 4.3
Summary: Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*
Update Date: 2017-09-18
Vulnerability Classification: XSS 
add_lines: 3
codeLink: https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_id: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_message: [views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98
del_lines: 0
file_name: chrome/browser/ui/views/extensions/shell_window_views.cc
files_changed: {"sha": "5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b", "filename": "chrome/browser/ui/views/extensions/shell_window_views.cc", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "raw_url": "https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5", "patch": "@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \"browser/ui/views/extensions/ShellWindowFrameView\";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }"}
func_after:  gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
  if (is_frameless_)
    return min_size;

   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
  int closeButtonOffsetX =
      (kCaptionHeight - close_button_->height()) / 2;
  int header_width = close_button_->width() + closeButtonOffsetX * 2;
  if (header_width > min_size.width())
    min_size.set_width(header_width);
  return min_size;
}

func_before:  gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
  int closeButtonOffsetX =
      (kCaptionHeight - close_button_->height()) / 2;
  int header_width = close_button_->width() + closeButtonOffsetX * 2;
  if (header_width > min_size.width())
    min_size.set_width(header_width);
  return min_size;
}

lang: C
lines_after:   if (is_frameless_)
    return min_size;


lines_before: 
parentID: 
patch: @@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     "browser/ui/views/extensions/ShellWindowFrameView";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }
project: Chrome
project_after: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
project_before: d7ddf81573776614bf124ce1845b99f9115fb64b
vul: 1
vul_func_with_fix:  gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
//fix_flaw_line_below:
//  if (is_frameless_)
//fix_flaw_line_below:
//    return min_size;
//fix_flaw_line_below:
//
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
  // Ensure we have enough space for the window icon and buttons.  We allow
  // the title string to collapse to zero width.
  int closeButtonOffsetX =
      (kCaptionHeight - close_button_->height()) / 2;
  int header_width = close_button_->width() + closeButtonOffsetX * 2;
  if (header_width > min_size.width())
    min_size.set_width(header_width);
  return min_size;
}


========================================

Entry ID: 184288
: 184288
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2012-2889
CVE Page: https://www.cvedetails.com/cve/CVE-2012-2889/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2012-09-26
Score: 4.3
Summary: Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*
Update Date: 2017-09-18
Vulnerability Classification: XSS 
add_lines: 3
codeLink: https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_id: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_message: [views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98
del_lines: 0
file_name: chrome/browser/ui/views/extensions/shell_window_views.cc
files_changed: {"sha": "5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b", "filename": "chrome/browser/ui/views/extensions/shell_window_views.cc", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "raw_url": "https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5", "patch": "@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \"browser/ui/views/extensions/ShellWindowFrameView\";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }"}
func_after:  gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
  if (is_frameless_)
    return client_bounds;

   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
  return gfx::Rect(client_bounds.x(),
                   std::max(0, client_bounds.y() - kCaptionHeight),
                   std::max(header_width, client_bounds.width()),
                   client_bounds.height() + kCaptionHeight);
}

func_before:  gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
  return gfx::Rect(client_bounds.x(),
                   std::max(0, client_bounds.y() - kCaptionHeight),
                   std::max(header_width, client_bounds.width()),
                   client_bounds.height() + kCaptionHeight);
}

lang: C
lines_after:   if (is_frameless_)
    return client_bounds;


lines_before: 
parentID: 
patch: @@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     "browser/ui/views/extensions/ShellWindowFrameView";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }
project: Chrome
project_after: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
project_before: d7ddf81573776614bf124ce1845b99f9115fb64b
vul: 1
vul_func_with_fix:  gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
//fix_flaw_line_below:
//  if (is_frameless_)
//fix_flaw_line_below:
//    return client_bounds;
//fix_flaw_line_below:
//
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
  return gfx::Rect(client_bounds.x(),
                   std::max(0, client_bounds.y() - kCaptionHeight),
                   std::max(header_width, client_bounds.width()),
                   client_bounds.height() + kCaptionHeight);
}


========================================

Entry ID: 184289
: 184289
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2012-2889
CVE Page: https://www.cvedetails.com/cve/CVE-2012-2889/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2012-09-26
Score: 4.3
Summary: Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*
Update Date: 2017-09-18
Vulnerability Classification: XSS 
add_lines: 14
codeLink: https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_id: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_message: [views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98
del_lines: 11
file_name: chrome/browser/ui/views/extensions/shell_window_views.cc
files_changed: {"sha": "5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b", "filename": "chrome/browser/ui/views/extensions/shell_window_views.cc", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "raw_url": "https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5", "patch": "@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \"browser/ui/views/extensions/ShellWindowFrameView\";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }"}
func_after:  void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;

  if (!is_frameless_) {
    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
    close_button_ = new views::ImageButton(this);
    close_button_->SetImage(views::CustomButton::BS_NORMAL,
        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
    close_button_->SetImage(views::CustomButton::BS_HOT,
        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
    close_button_->SetImage(views::CustomButton::BS_PUSHED,
        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
    close_button_->SetAccessibleName(
        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
    AddChildView(close_button_);
  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
  int outside_bounds = ui::GetDisplayLayout() == ui::LAYOUT_TOUCH ?
      kResizeOutsideBoundsSizeTouch :
      kResizeOutsideBoundsSize;
  window->set_hit_test_bounds_override_outer(
      gfx::Insets(-outside_bounds, -outside_bounds,
                  -outside_bounds, -outside_bounds));
  window->set_hit_test_bounds_override_inner(
      gfx::Insets(kResizeInsideBoundsSize, kResizeInsideBoundsSize,
                  kResizeInsideBoundsSize, kResizeInsideBoundsSize));
#endif
 }

func_before:  void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
  close_button_ = new views::ImageButton(this);
  close_button_->SetImage(views::CustomButton::BS_NORMAL,
      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
  close_button_->SetImage(views::CustomButton::BS_HOT,
      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
  close_button_->SetImage(views::CustomButton::BS_PUSHED,
      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
  close_button_->SetAccessibleName(
      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
  AddChildView(close_button_);
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
  int outside_bounds = ui::GetDisplayLayout() == ui::LAYOUT_TOUCH ?
      kResizeOutsideBoundsSizeTouch :
      kResizeOutsideBoundsSize;
  window->set_hit_test_bounds_override_outer(
      gfx::Insets(-outside_bounds, -outside_bounds,
                  -outside_bounds, -outside_bounds));
  window->set_hit_test_bounds_override_inner(
      gfx::Insets(kResizeInsideBoundsSize, kResizeInsideBoundsSize,
                  kResizeInsideBoundsSize, kResizeInsideBoundsSize));
#endif
 }

lang: C
lines_after: 
  if (!is_frameless_) {
    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
    close_button_ = new views::ImageButton(this);
    close_button_->SetImage(views::CustomButton::BS_NORMAL,
        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
    close_button_->SetImage(views::CustomButton::BS_HOT,
        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
    close_button_->SetImage(views::CustomButton::BS_PUSHED,
        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
    close_button_->SetAccessibleName(
        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
    AddChildView(close_button_);
  }

lines_before:   ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
  close_button_ = new views::ImageButton(this);
  close_button_->SetImage(views::CustomButton::BS_NORMAL,
      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
  close_button_->SetImage(views::CustomButton::BS_HOT,
      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
  close_button_->SetImage(views::CustomButton::BS_PUSHED,
      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
  close_button_->SetAccessibleName(
      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
  AddChildView(close_button_);

parentID: 
patch: @@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     "browser/ui/views/extensions/ShellWindowFrameView";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }
project: Chrome
project_after: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
project_before: d7ddf81573776614bf124ce1845b99f9115fb64b
vul: 1
vul_func_with_fix:  void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
//flaw_line_below:
  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
//flaw_line_below:
  close_button_ = new views::ImageButton(this);
//flaw_line_below:
  close_button_->SetImage(views::CustomButton::BS_NORMAL,
//flaw_line_below:
      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
//flaw_line_below:
  close_button_->SetImage(views::CustomButton::BS_HOT,
//flaw_line_below:
      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
//flaw_line_below:
  close_button_->SetImage(views::CustomButton::BS_PUSHED,
//flaw_line_below:
      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
//flaw_line_below:
  close_button_->SetAccessibleName(
//flaw_line_below:
      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
//flaw_line_below:
  AddChildView(close_button_);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  if (!is_frameless_) {
//fix_flaw_line_below:
//    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
//fix_flaw_line_below:
//    close_button_ = new views::ImageButton(this);
//fix_flaw_line_below:
//    close_button_->SetImage(views::CustomButton::BS_NORMAL,
//fix_flaw_line_below:
//        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
//fix_flaw_line_below:
//    close_button_->SetImage(views::CustomButton::BS_HOT,
//fix_flaw_line_below:
//        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
//fix_flaw_line_below:
//    close_button_->SetImage(views::CustomButton::BS_PUSHED,
//fix_flaw_line_below:
//        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
//fix_flaw_line_below:
//    close_button_->SetAccessibleName(
//fix_flaw_line_below:
//        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
//fix_flaw_line_below:
//    AddChildView(close_button_);
//fix_flaw_line_below:
//  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
  // Ensure we get resize cursors for a few pixels outside our bounds.
  int outside_bounds = ui::GetDisplayLayout() == ui::LAYOUT_TOUCH ?
      kResizeOutsideBoundsSizeTouch :
      kResizeOutsideBoundsSize;
  window->set_hit_test_bounds_override_outer(
      gfx::Insets(-outside_bounds, -outside_bounds,
                  -outside_bounds, -outside_bounds));
  // Ensure we get resize cursors just inside our bounds as well.
  // TODO(jeremya): do we need to update these when in fullscreen/maximized?
  window->set_hit_test_bounds_override_inner(
      gfx::Insets(kResizeInsideBoundsSize, kResizeInsideBoundsSize,
                  kResizeInsideBoundsSize, kResizeInsideBoundsSize));
#endif
 }


========================================

Entry ID: 184290
: 184290
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2012-2889
CVE Page: https://www.cvedetails.com/cve/CVE-2012-2889/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2012-09-26
Score: 4.3
Summary: Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*
Update Date: 2017-09-18
Vulnerability Classification: XSS 
add_lines: 2
codeLink: https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_id: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_message: [views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98
del_lines: 0
file_name: chrome/browser/ui/views/extensions/shell_window_views.cc
files_changed: {"sha": "5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b", "filename": "chrome/browser/ui/views/extensions/shell_window_views.cc", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "raw_url": "https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5", "patch": "@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \"browser/ui/views/extensions/ShellWindowFrameView\";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }"}
func_after:  void ShellWindowFrameView::Layout() {
  if (is_frameless_)
    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
  int closeButtonOffsetX = closeButtonOffsetY;
  close_button_->SetBounds(
      width() - closeButtonOffsetX - close_size.width(),
      closeButtonOffsetY,
      close_size.width(),
      close_size.height());
 }

func_before:  void ShellWindowFrameView::Layout() {
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
  int closeButtonOffsetX = closeButtonOffsetY;
  close_button_->SetBounds(
      width() - closeButtonOffsetX - close_size.width(),
      closeButtonOffsetY,
      close_size.width(),
      close_size.height());
 }

lang: C
lines_after:   if (is_frameless_)
    return;

lines_before: 
parentID: 
patch: @@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     "browser/ui/views/extensions/ShellWindowFrameView";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }
project: Chrome
project_after: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
project_before: d7ddf81573776614bf124ce1845b99f9115fb64b
vul: 1
vul_func_with_fix:  void ShellWindowFrameView::Layout() {
//fix_flaw_line_below:
//  if (is_frameless_)
//fix_flaw_line_below:
//    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
  int closeButtonOffsetX = closeButtonOffsetY;
  close_button_->SetBounds(
      width() - closeButtonOffsetX - close_size.width(),
      closeButtonOffsetY,
      close_size.width(),
      close_size.height());
 }


========================================

Entry ID: 184291
: 184291
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2012-2889
CVE Page: https://www.cvedetails.com/cve/CVE-2012-2889/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2012-09-26
Score: 4.3
Summary: Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*
Update Date: 2017-09-18
Vulnerability Classification: XSS 
add_lines: 2
codeLink: https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_id: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_message: [views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98
del_lines: 0
file_name: chrome/browser/ui/views/extensions/shell_window_views.cc
files_changed: {"sha": "5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b", "filename": "chrome/browser/ui/views/extensions/shell_window_views.cc", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "raw_url": "https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5", "patch": "@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \"browser/ui/views/extensions/ShellWindowFrameView\";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }"}
func_after:  void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
  if (is_frameless_)
    return;
   SkPaint paint;
   paint.setAntiAlias(false);
  paint.setStyle(SkPaint::kFill_Style);
  paint.setColor(SK_ColorWHITE);
  gfx::Path path;
  const int radius = 1;
  path.moveTo(0, radius);
  path.lineTo(radius, 0);
  path.lineTo(width() - radius - 1, 0);
  path.lineTo(width(), radius + 1);
  path.lineTo(width(), kCaptionHeight);
  path.lineTo(0, kCaptionHeight);
  path.close();
  canvas->DrawPath(path, paint);
}

func_before:  void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
   SkPaint paint;
   paint.setAntiAlias(false);
  paint.setStyle(SkPaint::kFill_Style);
  paint.setColor(SK_ColorWHITE);
  gfx::Path path;
  const int radius = 1;
  path.moveTo(0, radius);
  path.lineTo(radius, 0);
  path.lineTo(width() - radius - 1, 0);
  path.lineTo(width(), radius + 1);
  path.lineTo(width(), kCaptionHeight);
  path.lineTo(0, kCaptionHeight);
  path.close();
  canvas->DrawPath(path, paint);
}

lang: C
lines_after:   if (is_frameless_)
    return;

lines_before: 
parentID: 
patch: @@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     "browser/ui/views/extensions/ShellWindowFrameView";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }
project: Chrome
project_after: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
project_before: d7ddf81573776614bf124ce1845b99f9115fb64b
vul: 1
vul_func_with_fix:  void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
//fix_flaw_line_below:
//  if (is_frameless_)
//fix_flaw_line_below:
//    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
  paint.setStyle(SkPaint::kFill_Style);
  paint.setColor(SK_ColorWHITE);
  gfx::Path path;
  const int radius = 1;
  path.moveTo(0, radius);
  path.lineTo(radius, 0);
  path.lineTo(width() - radius - 1, 0);
  path.lineTo(width(), radius + 1);
  path.lineTo(width(), kCaptionHeight);
  path.lineTo(0, kCaptionHeight);
  path.close();
  canvas->DrawPath(path, paint);
}


========================================

Entry ID: 184292
: 184292
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2012-2889
CVE Page: https://www.cvedetails.com/cve/CVE-2012-2889/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2012-09-26
Score: 4.3
Summary: Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*
Update Date: 2017-09-18
Vulnerability Classification: XSS 
add_lines: 3
codeLink: https://github.com/chromium/chromium/commit/7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_id: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
commit_message: [views] Remove header bar on shell windows created with {frame: none}.

BUG=130182
R=ben@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10597003

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143439 0039d316-1c4b-4281-b951-d872f2087c98
del_lines: 1
file_name: chrome/browser/ui/views/extensions/shell_window_views.cc
files_changed: {"sha": "5eaf091f1a2467bfcc2cc35fdf5fd6cbad76f95b", "filename": "chrome/browser/ui/views/extensions/shell_window_views.cc", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/chromium/chromium/blob/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "raw_url": "https://github.com/chromium/chromium/raw/7f8cdab6fda192d15e45a3e9682b1eec427870c5/chrome/browser/ui/views/extensions/shell_window_views.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/views/extensions/shell_window_views.cc?ref=7f8cdab6fda192d15e45a3e9682b1eec427870c5", "patch": "@@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n  public:\n   static const char kViewClassName[];\n \n-  ShellWindowFrameView();\n+  explicit ShellWindowFrameView(bool frameless);\n   virtual ~ShellWindowFrameView();\n \n   void Init(views::Widget* frame);\n@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,\n   views::Widget* frame_;\n   views::ImageButton* close_button_;\n \n+  bool is_frameless_;\n+\n   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);\n };\n \n const char ShellWindowFrameView::kViewClassName[] =\n     \"browser/ui/views/extensions/ShellWindowFrameView\";\n \n-ShellWindowFrameView::ShellWindowFrameView()\n+ShellWindowFrameView::ShellWindowFrameView(bool frameless)\n     : frame_(NULL),\n-      close_button_(NULL) {\n+      close_button_(NULL),\n+      is_frameless_(frameless) {\n }\n \n ShellWindowFrameView::~ShellWindowFrameView() {\n }\n \n void ShellWindowFrameView::Init(views::Widget* frame) {\n   frame_ = frame;\n-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n-  close_button_ = new views::ImageButton(this);\n-  close_button_->SetImage(views::CustomButton::BS_NORMAL,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_HOT,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n-  close_button_->SetImage(views::CustomButton::BS_PUSHED,\n-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n-  close_button_->SetAccessibleName(\n-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n-  AddChildView(close_button_);\n+\n+  if (!is_frameless_) {\n+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n+    close_button_ = new views::ImageButton(this);\n+    close_button_->SetImage(views::CustomButton::BS_NORMAL,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_HOT,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());\n+    close_button_->SetImage(views::CustomButton::BS_PUSHED,\n+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());\n+    close_button_->SetAccessibleName(\n+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));\n+    AddChildView(close_button_);\n+  }\n \n #if defined(USE_ASH)\n   aura::Window* window = frame->GetNativeWindow();\n@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {\n }\n \n gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {\n-  if (frame_->IsFullscreen())\n+  if (is_frameless_ || frame_->IsFullscreen())\n     return bounds();\n   return gfx::Rect(0, kCaptionHeight, width(),\n       std::max(0, height() - kCaptionHeight));\n }\n \n gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(\n       const gfx::Rect& client_bounds) const {\n+  if (is_frameless_)\n+    return client_bounds;\n+\n   int closeButtonOffsetX =\n       (kCaptionHeight - close_button_->height()) / 2;\n   int header_width = close_button_->width() + closeButtonOffsetX * 2;\n@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {\n }\n \n void ShellWindowFrameView::Layout() {\n+  if (is_frameless_)\n+    return;\n   gfx::Size close_size = close_button_->GetPreferredSize();\n   int closeButtonOffsetY =\n       (kCaptionHeight - close_size.height()) / 2;\n@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {\n }\n \n void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {\n+  if (is_frameless_)\n+    return;\n   // TODO(jeremya): different look for inactive?\n   SkPaint paint;\n   paint.setAntiAlias(false);\n@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {\n \n gfx::Size ShellWindowFrameView::GetMinimumSize() {\n   gfx::Size min_size = frame_->client_view()->GetMinimumSize();\n+  if (is_frameless_)\n+    return min_size;\n+\n   // Ensure we can display the top of the caption area.\n   gfx::Rect client_bounds = GetBoundsForClientView();\n   min_size.Enlarge(0, client_bounds.y());\n@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {\n \n gfx::Size ShellWindowFrameView::GetMaximumSize() {\n   gfx::Size max_size = frame_->client_view()->GetMaximumSize();\n+  if (is_frameless_)\n+    return max_size;\n+\n   if (!max_size.IsEmpty()) {\n     gfx::Rect client_bounds = GetBoundsForClientView();\n     max_size.Enlarge(0, client_bounds.y());\n@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {\n \n void ShellWindowFrameView::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n+  DCHECK(!is_frameless_);\n   if (sender == close_button_)\n     frame_->Close();\n }\n@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {\n \n views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n+  ShellWindowFrameView* frame_view =\n+      new ShellWindowFrameView(use_custom_frame_);\n   frame_view->Init(window_);\n   return frame_view;\n }"}
func_after: ShellWindowFrameView::ShellWindowFrameView()
ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
      close_button_(NULL),
      is_frameless_(frameless) {
 }

func_before: ShellWindowFrameView::ShellWindowFrameView()
     : frame_(NULL),
      close_button_(NULL) {
 }

lang: C
lines_after: ShellWindowFrameView::ShellWindowFrameView(bool frameless)
      close_button_(NULL),
      is_frameless_(frameless) {

lines_before:       close_button_(NULL) {

parentID: 
patch: @@ -63,7 +63,7 @@ class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
-  ShellWindowFrameView();
+  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
@@ -94,33 +94,39 @@ class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
+  bool is_frameless_;
+
   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     "browser/ui/views/extensions/ShellWindowFrameView";
 
-ShellWindowFrameView::ShellWindowFrameView()
+ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
-      close_button_(NULL) {
+      close_button_(NULL),
+      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;
-  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
-  close_button_ = new views::ImageButton(this);
-  close_button_->SetImage(views::CustomButton::BS_NORMAL,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_HOT,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
-  close_button_->SetImage(views::CustomButton::BS_PUSHED,
-      rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
-  close_button_->SetAccessibleName(
-      l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
-  AddChildView(close_button_);
+
+  if (!is_frameless_) {
+    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+    close_button_ = new views::ImageButton(this);
+    close_button_->SetImage(views::CustomButton::BS_NORMAL,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_HOT,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
+    close_button_->SetImage(views::CustomButton::BS_PUSHED,
+        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
+    close_button_->SetAccessibleName(
+        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
+    AddChildView(close_button_);
+  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
@@ -140,14 +146,17 @@ void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
-  if (frame_->IsFullscreen())
+  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
+  if (is_frameless_)
+    return client_bounds;
+
   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
@@ -216,6 +225,8 @@ gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
+  if (is_frameless_)
+    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
@@ -228,6 +239,8 @@ void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
+  if (is_frameless_)
+    return;
   // TODO(jeremya): different look for inactive?
   SkPaint paint;
   paint.setAntiAlias(false);
@@ -251,6 +264,9 @@ std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
+  if (is_frameless_)
+    return min_size;
+
   // Ensure we can display the top of the caption area.
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
@@ -266,6 +282,9 @@ gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
+  if (is_frameless_)
+    return max_size;
+
   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
@@ -275,6 +294,7 @@ gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
+  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
@@ -447,7 +467,8 @@ views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
-  ShellWindowFrameView* frame_view = new ShellWindowFrameView();
+  ShellWindowFrameView* frame_view =
+      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }
project: Chrome
project_after: 7f8cdab6fda192d15e45a3e9682b1eec427870c5
project_before: d7ddf81573776614bf124ce1845b99f9115fb64b
vul: 1
vul_func_with_fix: ShellWindowFrameView::ShellWindowFrameView()
//fix_flaw_line_below:
//ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
//flaw_line_below:
      close_button_(NULL) {
//fix_flaw_line_below:
//      close_button_(NULL),
//fix_flaw_line_below:
//      is_frameless_(frameless) {
 }


========================================

Entry ID: 184293
: 184293
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2012-2886
CVE Page: https://www.cvedetails.com/cve/CVE-2012-2886/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2012-09-26
Score: 4.3
Summary: Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors related to the Google V8 bindings, aka *Universal XSS (UXSS).*
Update Date: 2018-10-30
Vulnerability Classification: XSS 
add_lines: 2
codeLink: https://github.com/chromium/chromium/commit/10b688f204a81d8447c83021624220607353552e
commit_id: 10b688f204a81d8447c83021624220607353552e
commit_message: ash: Make UserActivityDetector ignore synthetic mouse events

This may have been preventing us from suspending (e.g.
mouse event is synthesized in response to lock window being
shown so Chrome tells powerd that the user is active).

BUG=133419
TEST=added


Review URL: https://chromiumcodereview.appspot.com/10574044

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143437 0039d316-1c4b-4281-b951-d872f2087c98
del_lines: 1
file_name: ash/wm/user_activity_detector.cc
files_changed: {"sha": "5a3b04dc4fb34943c5bb0a1129e74498162f68be", "filename": "ash/ash.gyp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/ash.gyp", "raw_url": "https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/ash.gyp", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/ash.gyp?ref=10b688f204a81d8447c83021624220607353552e", "patch": "@@ -421,6 +421,7 @@\n         'wm/system_gesture_event_filter_unittest.cc',\n         'wm/system_modal_container_layout_manager_unittest.cc',\n         'wm/toplevel_window_event_filter_unittest.cc',\n+        'wm/user_activity_detector_unittest.cc',\n         'wm/video_detector_unittest.cc',\n         'wm/visibility_controller_unittest.cc',\n         'wm/window_animations_unittest.cc',"}<_**next**_>{"sha": "5329087294664a540f505add21d0850ec2cc4518", "filename": "ash/wm/user_activity_detector.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector.cc", "raw_url": "https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/wm/user_activity_detector.cc?ref=10b688f204a81d8447c83021624220607353552e", "patch": "@@ -5,6 +5,7 @@\n #include \"ash/wm/user_activity_detector.h\"\n \n #include \"ash/wm/user_activity_observer.h\"\n+#include \"ui/aura/event.h\"\n \n namespace ash {\n \n@@ -32,7 +33,8 @@ bool UserActivityDetector::PreHandleKeyEvent(aura::Window* target,\n \n bool UserActivityDetector::PreHandleMouseEvent(aura::Window* target,\n                                                aura::MouseEvent* event) {\n-  MaybeNotify();\n+  if (!(event->flags() & ui::EF_IS_SYNTHESIZED))\n+    MaybeNotify();\n   return false;\n }\n \n@@ -51,7 +53,8 @@ ui::GestureStatus UserActivityDetector::PreHandleGestureEvent(\n }\n \n void UserActivityDetector::MaybeNotify() {\n-  base::TimeTicks now = base::TimeTicks::Now();\n+  base::TimeTicks now =\n+      !now_for_test_.is_null() ? now_for_test_ : base::TimeTicks::Now();\n   if (last_observer_notification_time_.is_null() ||\n       (now - last_observer_notification_time_).InSecondsF() >=\n       kNotifyIntervalSec) {"}<_**next**_>{"sha": "a6114db8e48d3c4edeb91d872bf4e3c80b53f068", "filename": "ash/wm/user_activity_detector.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector.h", "raw_url": "https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector.h", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/wm/user_activity_detector.h?ref=10b688f204a81d8447c83021624220607353552e", "patch": "@@ -27,6 +27,8 @@ class ASH_EXPORT UserActivityDetector : public aura::EventFilter {\n   UserActivityDetector();\n   virtual ~UserActivityDetector();\n \n+  void set_now_for_test(base::TimeTicks now) { now_for_test_ = now; }\n+\n   void AddObserver(UserActivityObserver* observer);\n   void RemoveObserver(UserActivityObserver* observer);\n \n@@ -53,6 +55,10 @@ class ASH_EXPORT UserActivityDetector : public aura::EventFilter {\n   // Last time at which we notified observers that the user was active.\n   base::TimeTicks last_observer_notification_time_;\n \n+  // If set, used when the current time is needed.  This can be set by tests to\n+  // simulate the passage of time.\n+  base::TimeTicks now_for_test_;\n+\n   DISALLOW_COPY_AND_ASSIGN(UserActivityDetector);\n };\n "}<_**next**_>{"sha": "3af566b469c90b336b46254f7ef4e5bd249c8684", "filename": "ash/wm/user_activity_detector_unittest.cc", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector_unittest.cc", "raw_url": "https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector_unittest.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/wm/user_activity_detector_unittest.cc?ref=10b688f204a81d8447c83021624220607353552e", "patch": "@@ -0,0 +1,156 @@\n+// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \"ash/wm/user_activity_detector.h\"\n+\n+#include \"ash/shell.h\"\n+#include \"ash/test/ash_test_base.h\"\n+#include \"ash/wm/user_activity_observer.h\"\n+#include \"base/compiler_specific.h\"\n+#include \"base/memory/scoped_ptr.h\"\n+#include \"base/time.h\"\n+#include \"ui/aura/event.h\"\n+#include \"ui/aura/test/test_windows.h\"\n+#include \"ui/aura/window.h\"\n+#include \"ui/base/events.h\"\n+#include \"ui/base/keycodes/keyboard_codes.h\"\n+#include \"ui/gfx/point.h\"\n+\n+namespace ash {\n+namespace test {\n+\n+// Implementation that just counts the number of times we've been told that the\n+// user is active.\n+class TestUserActivityObserver : public UserActivityObserver {\n+ public:\n+  TestUserActivityObserver() : num_invocations_(0) {}\n+\n+  int num_invocations() const { return num_invocations_; }\n+  void reset_stats() { num_invocations_ = 0; }\n+\n+  // UserActivityObserver implementation.\n+  virtual void OnUserActivity() OVERRIDE { num_invocations_++; }\n+\n+ private:\n+  // Number of times that OnUserActivity() has been called.\n+  int num_invocations_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(TestUserActivityObserver);\n+};\n+\n+class UserActivityDetectorTest : public AshTestBase {\n+ public:\n+  UserActivityDetectorTest() {}\n+  virtual ~UserActivityDetectorTest() {}\n+\n+  virtual void SetUp() OVERRIDE {\n+    AshTestBase::SetUp();\n+    observer_.reset(new TestUserActivityObserver);\n+    detector_ = Shell::GetInstance()->user_activity_detector();\n+    detector_->AddObserver(observer_.get());\n+\n+    now_ = base::TimeTicks::Now();\n+    detector_->set_now_for_test(now_);\n+  }\n+\n+  virtual void TearDown() OVERRIDE {\n+    detector_->RemoveObserver(observer_.get());\n+    AshTestBase::TearDown();\n+  }\n+\n+ protected:\n+  // Move |detector_|'s idea of the current time forward by |delta|.\n+  void AdvanceTime(base::TimeDelta delta) {\n+    now_ += delta;\n+    detector_->set_now_for_test(now_);\n+  }\n+\n+  UserActivityDetector* detector_;  // not owned\n+\n+  scoped_ptr<TestUserActivityObserver> observer_;\n+\n+  base::TimeTicks now_;\n+\n+ private:\n+  DISALLOW_COPY_AND_ASSIGN(UserActivityDetectorTest);\n+};\n+\n+// Checks that the observer is notified in response to different types of input\n+// events.\n+TEST_F(UserActivityDetectorTest, Basic) {\n+  scoped_ptr<aura::Window> window(\n+      aura::test::CreateTestWindowWithId(12345, NULL));\n+\n+  aura::KeyEvent key_event(ui::ET_KEY_PRESSED, ui::VKEY_A, ui::EF_NONE);\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &key_event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  base::TimeDelta advance_delta =\n+      base::TimeDelta::FromSeconds(UserActivityDetector::kNotifyIntervalSec);\n+  AdvanceTime(advance_delta);\n+  aura::MouseEvent mouse_event(\n+      ui::ET_MOUSE_MOVED, gfx::Point(), gfx::Point(), ui::EF_NONE);\n+  EXPECT_FALSE(detector_->PreHandleMouseEvent(window.get(), &mouse_event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  AdvanceTime(advance_delta);\n+  aura::TouchEvent touch_event(\n+      ui::ET_TOUCH_PRESSED, gfx::Point(), 0, base::TimeDelta());\n+  EXPECT_FALSE(detector_->PreHandleTouchEvent(window.get(), &touch_event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  AdvanceTime(advance_delta);\n+  aura::GestureEvent gesture_event(\n+      ui::ET_GESTURE_TAP, 0, 0, ui::EF_NONE, base::Time(), 0, 0, 0U);\n+  EXPECT_FALSE(detector_->PreHandleGestureEvent(window.get(), &gesture_event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+}\n+\n+// Checks that observers aren't notified too frequently.\n+TEST_F(UserActivityDetectorTest, RateLimitNotifications) {\n+  scoped_ptr<aura::Window> window(\n+      aura::test::CreateTestWindowWithId(12345, NULL));\n+\n+  // The observer should be notified about a key event.\n+  aura::KeyEvent event(ui::ET_KEY_PRESSED, ui::VKEY_A, ui::EF_NONE);\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  // It shouldn't be notified if a second event occurs in the same second,\n+  // though.\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &event));\n+  EXPECT_EQ(0, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  // Advance the time, but not quite enough for another notification to be sent.\n+  AdvanceTime(\n+      base::TimeDelta::FromSeconds(\n+          UserActivityDetector::kNotifyIntervalSec - 1));\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &event));\n+  EXPECT_EQ(0, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  // One second later, we should send a notification again.\n+  AdvanceTime(base::TimeDelta::FromSeconds(1));\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+}\n+\n+// Checks that the detector ignores synthetic mouse events.\n+TEST_F(UserActivityDetectorTest, IgnoreSyntheticMouseEvents) {\n+  scoped_ptr<aura::Window> window(\n+      aura::test::CreateTestWindowWithId(12345, NULL));\n+  aura::MouseEvent mouse_event(\n+      ui::ET_MOUSE_MOVED, gfx::Point(), gfx::Point(), ui::EF_IS_SYNTHESIZED);\n+  EXPECT_FALSE(detector_->PreHandleMouseEvent(window.get(), &mouse_event));\n+  EXPECT_EQ(0, observer_->num_invocations());\n+}\n+\n+}  // namespace test\n+}  // namespace ash"}<_**next**_>{"sha": "0730ee7b7e50968ca9b08da0b23939667fa989c7", "filename": "ash/wm/video_detector_unittest.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/wm/video_detector_unittest.cc", "raw_url": "https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/wm/video_detector_unittest.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/wm/video_detector_unittest.cc?ref=10b688f204a81d8447c83021624220607353552e", "patch": "@@ -53,6 +53,11 @@ class VideoDetectorTest : public AshTestBase {\n     detector_->set_now_for_test(now_);\n   }\n \n+  virtual void TearDown() OVERRIDE {\n+    detector_->RemoveObserver(observer_.get());\n+    AshTestBase::TearDown();\n+  }\n+\n  protected:\n   // Move |detector_|'s idea of the current time forward by |delta|.\n   void AdvanceTime(base::TimeDelta delta) {"}
func_after:  void UserActivityDetector::MaybeNotify() {
  base::TimeTicks now =
      !now_for_test_.is_null() ? now_for_test_ : base::TimeTicks::Now();
   if (last_observer_notification_time_.is_null() ||
       (now - last_observer_notification_time_).InSecondsF() >=
       kNotifyIntervalSec) {
    FOR_EACH_OBSERVER(UserActivityObserver, observers_, OnUserActivity());
    last_observer_notification_time_ = now;
  }
}

func_before:  void UserActivityDetector::MaybeNotify() {
  base::TimeTicks now = base::TimeTicks::Now();
   if (last_observer_notification_time_.is_null() ||
       (now - last_observer_notification_time_).InSecondsF() >=
       kNotifyIntervalSec) {
    FOR_EACH_OBSERVER(UserActivityObserver, observers_, OnUserActivity());
    last_observer_notification_time_ = now;
  }
}

lang: C
lines_after:   base::TimeTicks now =
      !now_for_test_.is_null() ? now_for_test_ : base::TimeTicks::Now();

lines_before:   base::TimeTicks now = base::TimeTicks::Now();

parentID: 
patch: @@ -5,6 +5,7 @@
 #include "ash/wm/user_activity_detector.h"
 
 #include "ash/wm/user_activity_observer.h"
+#include "ui/aura/event.h"
 
 namespace ash {
 
@@ -32,7 +33,8 @@ bool UserActivityDetector::PreHandleKeyEvent(aura::Window* target,
 
 bool UserActivityDetector::PreHandleMouseEvent(aura::Window* target,
                                                aura::MouseEvent* event) {
-  MaybeNotify();
+  if (!(event->flags() & ui::EF_IS_SYNTHESIZED))
+    MaybeNotify();
   return false;
 }
 
@@ -51,7 +53,8 @@ ui::GestureStatus UserActivityDetector::PreHandleGestureEvent(
 }
 
 void UserActivityDetector::MaybeNotify() {
-  base::TimeTicks now = base::TimeTicks::Now();
+  base::TimeTicks now =
+      !now_for_test_.is_null() ? now_for_test_ : base::TimeTicks::Now();
   if (last_observer_notification_time_.is_null() ||
       (now - last_observer_notification_time_).InSecondsF() >=
       kNotifyIntervalSec) {
project: Chrome
project_after: 10b688f204a81d8447c83021624220607353552e
project_before: 47cadc4c09a3732a47efdb561cd6555735487841
vul: 1
vul_func_with_fix:  void UserActivityDetector::MaybeNotify() {
//flaw_line_below:
  base::TimeTicks now = base::TimeTicks::Now();
//fix_flaw_line_below:
//  base::TimeTicks now =
//fix_flaw_line_below:
//      !now_for_test_.is_null() ? now_for_test_ : base::TimeTicks::Now();
   if (last_observer_notification_time_.is_null() ||
       (now - last_observer_notification_time_).InSecondsF() >=
       kNotifyIntervalSec) {
    FOR_EACH_OBSERVER(UserActivityObserver, observers_, OnUserActivity());
    last_observer_notification_time_ = now;
  }
}


========================================

Entry ID: 184294
: 184294
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2012-2886
CVE Page: https://www.cvedetails.com/cve/CVE-2012-2886/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2012-09-26
Score: 4.3
Summary: Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors related to the Google V8 bindings, aka *Universal XSS (UXSS).*
Update Date: 2018-10-30
Vulnerability Classification: XSS 
add_lines: 2
codeLink: https://github.com/chromium/chromium/commit/10b688f204a81d8447c83021624220607353552e
commit_id: 10b688f204a81d8447c83021624220607353552e
commit_message: ash: Make UserActivityDetector ignore synthetic mouse events

This may have been preventing us from suspending (e.g.
mouse event is synthesized in response to lock window being
shown so Chrome tells powerd that the user is active).

BUG=133419
TEST=added


Review URL: https://chromiumcodereview.appspot.com/10574044

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@143437 0039d316-1c4b-4281-b951-d872f2087c98
del_lines: 1
file_name: ash/wm/user_activity_detector.cc
files_changed: {"sha": "5a3b04dc4fb34943c5bb0a1129e74498162f68be", "filename": "ash/ash.gyp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/ash.gyp", "raw_url": "https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/ash.gyp", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/ash.gyp?ref=10b688f204a81d8447c83021624220607353552e", "patch": "@@ -421,6 +421,7 @@\n         'wm/system_gesture_event_filter_unittest.cc',\n         'wm/system_modal_container_layout_manager_unittest.cc',\n         'wm/toplevel_window_event_filter_unittest.cc',\n+        'wm/user_activity_detector_unittest.cc',\n         'wm/video_detector_unittest.cc',\n         'wm/visibility_controller_unittest.cc',\n         'wm/window_animations_unittest.cc',"}<_**next**_>{"sha": "5329087294664a540f505add21d0850ec2cc4518", "filename": "ash/wm/user_activity_detector.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector.cc", "raw_url": "https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/wm/user_activity_detector.cc?ref=10b688f204a81d8447c83021624220607353552e", "patch": "@@ -5,6 +5,7 @@\n #include \"ash/wm/user_activity_detector.h\"\n \n #include \"ash/wm/user_activity_observer.h\"\n+#include \"ui/aura/event.h\"\n \n namespace ash {\n \n@@ -32,7 +33,8 @@ bool UserActivityDetector::PreHandleKeyEvent(aura::Window* target,\n \n bool UserActivityDetector::PreHandleMouseEvent(aura::Window* target,\n                                                aura::MouseEvent* event) {\n-  MaybeNotify();\n+  if (!(event->flags() & ui::EF_IS_SYNTHESIZED))\n+    MaybeNotify();\n   return false;\n }\n \n@@ -51,7 +53,8 @@ ui::GestureStatus UserActivityDetector::PreHandleGestureEvent(\n }\n \n void UserActivityDetector::MaybeNotify() {\n-  base::TimeTicks now = base::TimeTicks::Now();\n+  base::TimeTicks now =\n+      !now_for_test_.is_null() ? now_for_test_ : base::TimeTicks::Now();\n   if (last_observer_notification_time_.is_null() ||\n       (now - last_observer_notification_time_).InSecondsF() >=\n       kNotifyIntervalSec) {"}<_**next**_>{"sha": "a6114db8e48d3c4edeb91d872bf4e3c80b53f068", "filename": "ash/wm/user_activity_detector.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector.h", "raw_url": "https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector.h", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/wm/user_activity_detector.h?ref=10b688f204a81d8447c83021624220607353552e", "patch": "@@ -27,6 +27,8 @@ class ASH_EXPORT UserActivityDetector : public aura::EventFilter {\n   UserActivityDetector();\n   virtual ~UserActivityDetector();\n \n+  void set_now_for_test(base::TimeTicks now) { now_for_test_ = now; }\n+\n   void AddObserver(UserActivityObserver* observer);\n   void RemoveObserver(UserActivityObserver* observer);\n \n@@ -53,6 +55,10 @@ class ASH_EXPORT UserActivityDetector : public aura::EventFilter {\n   // Last time at which we notified observers that the user was active.\n   base::TimeTicks last_observer_notification_time_;\n \n+  // If set, used when the current time is needed.  This can be set by tests to\n+  // simulate the passage of time.\n+  base::TimeTicks now_for_test_;\n+\n   DISALLOW_COPY_AND_ASSIGN(UserActivityDetector);\n };\n "}<_**next**_>{"sha": "3af566b469c90b336b46254f7ef4e5bd249c8684", "filename": "ash/wm/user_activity_detector_unittest.cc", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector_unittest.cc", "raw_url": "https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/wm/user_activity_detector_unittest.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/wm/user_activity_detector_unittest.cc?ref=10b688f204a81d8447c83021624220607353552e", "patch": "@@ -0,0 +1,156 @@\n+// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \"ash/wm/user_activity_detector.h\"\n+\n+#include \"ash/shell.h\"\n+#include \"ash/test/ash_test_base.h\"\n+#include \"ash/wm/user_activity_observer.h\"\n+#include \"base/compiler_specific.h\"\n+#include \"base/memory/scoped_ptr.h\"\n+#include \"base/time.h\"\n+#include \"ui/aura/event.h\"\n+#include \"ui/aura/test/test_windows.h\"\n+#include \"ui/aura/window.h\"\n+#include \"ui/base/events.h\"\n+#include \"ui/base/keycodes/keyboard_codes.h\"\n+#include \"ui/gfx/point.h\"\n+\n+namespace ash {\n+namespace test {\n+\n+// Implementation that just counts the number of times we've been told that the\n+// user is active.\n+class TestUserActivityObserver : public UserActivityObserver {\n+ public:\n+  TestUserActivityObserver() : num_invocations_(0) {}\n+\n+  int num_invocations() const { return num_invocations_; }\n+  void reset_stats() { num_invocations_ = 0; }\n+\n+  // UserActivityObserver implementation.\n+  virtual void OnUserActivity() OVERRIDE { num_invocations_++; }\n+\n+ private:\n+  // Number of times that OnUserActivity() has been called.\n+  int num_invocations_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(TestUserActivityObserver);\n+};\n+\n+class UserActivityDetectorTest : public AshTestBase {\n+ public:\n+  UserActivityDetectorTest() {}\n+  virtual ~UserActivityDetectorTest() {}\n+\n+  virtual void SetUp() OVERRIDE {\n+    AshTestBase::SetUp();\n+    observer_.reset(new TestUserActivityObserver);\n+    detector_ = Shell::GetInstance()->user_activity_detector();\n+    detector_->AddObserver(observer_.get());\n+\n+    now_ = base::TimeTicks::Now();\n+    detector_->set_now_for_test(now_);\n+  }\n+\n+  virtual void TearDown() OVERRIDE {\n+    detector_->RemoveObserver(observer_.get());\n+    AshTestBase::TearDown();\n+  }\n+\n+ protected:\n+  // Move |detector_|'s idea of the current time forward by |delta|.\n+  void AdvanceTime(base::TimeDelta delta) {\n+    now_ += delta;\n+    detector_->set_now_for_test(now_);\n+  }\n+\n+  UserActivityDetector* detector_;  // not owned\n+\n+  scoped_ptr<TestUserActivityObserver> observer_;\n+\n+  base::TimeTicks now_;\n+\n+ private:\n+  DISALLOW_COPY_AND_ASSIGN(UserActivityDetectorTest);\n+};\n+\n+// Checks that the observer is notified in response to different types of input\n+// events.\n+TEST_F(UserActivityDetectorTest, Basic) {\n+  scoped_ptr<aura::Window> window(\n+      aura::test::CreateTestWindowWithId(12345, NULL));\n+\n+  aura::KeyEvent key_event(ui::ET_KEY_PRESSED, ui::VKEY_A, ui::EF_NONE);\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &key_event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  base::TimeDelta advance_delta =\n+      base::TimeDelta::FromSeconds(UserActivityDetector::kNotifyIntervalSec);\n+  AdvanceTime(advance_delta);\n+  aura::MouseEvent mouse_event(\n+      ui::ET_MOUSE_MOVED, gfx::Point(), gfx::Point(), ui::EF_NONE);\n+  EXPECT_FALSE(detector_->PreHandleMouseEvent(window.get(), &mouse_event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  AdvanceTime(advance_delta);\n+  aura::TouchEvent touch_event(\n+      ui::ET_TOUCH_PRESSED, gfx::Point(), 0, base::TimeDelta());\n+  EXPECT_FALSE(detector_->PreHandleTouchEvent(window.get(), &touch_event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  AdvanceTime(advance_delta);\n+  aura::GestureEvent gesture_event(\n+      ui::ET_GESTURE_TAP, 0, 0, ui::EF_NONE, base::Time(), 0, 0, 0U);\n+  EXPECT_FALSE(detector_->PreHandleGestureEvent(window.get(), &gesture_event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+}\n+\n+// Checks that observers aren't notified too frequently.\n+TEST_F(UserActivityDetectorTest, RateLimitNotifications) {\n+  scoped_ptr<aura::Window> window(\n+      aura::test::CreateTestWindowWithId(12345, NULL));\n+\n+  // The observer should be notified about a key event.\n+  aura::KeyEvent event(ui::ET_KEY_PRESSED, ui::VKEY_A, ui::EF_NONE);\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  // It shouldn't be notified if a second event occurs in the same second,\n+  // though.\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &event));\n+  EXPECT_EQ(0, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  // Advance the time, but not quite enough for another notification to be sent.\n+  AdvanceTime(\n+      base::TimeDelta::FromSeconds(\n+          UserActivityDetector::kNotifyIntervalSec - 1));\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &event));\n+  EXPECT_EQ(0, observer_->num_invocations());\n+  observer_->reset_stats();\n+\n+  // One second later, we should send a notification again.\n+  AdvanceTime(base::TimeDelta::FromSeconds(1));\n+  EXPECT_FALSE(detector_->PreHandleKeyEvent(window.get(), &event));\n+  EXPECT_EQ(1, observer_->num_invocations());\n+}\n+\n+// Checks that the detector ignores synthetic mouse events.\n+TEST_F(UserActivityDetectorTest, IgnoreSyntheticMouseEvents) {\n+  scoped_ptr<aura::Window> window(\n+      aura::test::CreateTestWindowWithId(12345, NULL));\n+  aura::MouseEvent mouse_event(\n+      ui::ET_MOUSE_MOVED, gfx::Point(), gfx::Point(), ui::EF_IS_SYNTHESIZED);\n+  EXPECT_FALSE(detector_->PreHandleMouseEvent(window.get(), &mouse_event));\n+  EXPECT_EQ(0, observer_->num_invocations());\n+}\n+\n+}  // namespace test\n+}  // namespace ash"}<_**next**_>{"sha": "0730ee7b7e50968ca9b08da0b23939667fa989c7", "filename": "ash/wm/video_detector_unittest.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/chromium/chromium/blob/10b688f204a81d8447c83021624220607353552e/ash/wm/video_detector_unittest.cc", "raw_url": "https://github.com/chromium/chromium/raw/10b688f204a81d8447c83021624220607353552e/ash/wm/video_detector_unittest.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/wm/video_detector_unittest.cc?ref=10b688f204a81d8447c83021624220607353552e", "patch": "@@ -53,6 +53,11 @@ class VideoDetectorTest : public AshTestBase {\n     detector_->set_now_for_test(now_);\n   }\n \n+  virtual void TearDown() OVERRIDE {\n+    detector_->RemoveObserver(observer_.get());\n+    AshTestBase::TearDown();\n+  }\n+\n  protected:\n   // Move |detector_|'s idea of the current time forward by |delta|.\n   void AdvanceTime(base::TimeDelta delta) {"}
func_after:  bool UserActivityDetector::PreHandleMouseEvent(aura::Window* target,
                                                aura::MouseEvent* event) {
  if (!(event->flags() & ui::EF_IS_SYNTHESIZED))
    MaybeNotify();
   return false;
 }

func_before:  bool UserActivityDetector::PreHandleMouseEvent(aura::Window* target,
                                                aura::MouseEvent* event) {
  MaybeNotify();
   return false;
 }

lang: C
lines_after:   if (!(event->flags() & ui::EF_IS_SYNTHESIZED))
    MaybeNotify();

lines_before:   MaybeNotify();

parentID: 
patch: @@ -5,6 +5,7 @@
 #include "ash/wm/user_activity_detector.h"
 
 #include "ash/wm/user_activity_observer.h"
+#include "ui/aura/event.h"
 
 namespace ash {
 
@@ -32,7 +33,8 @@ bool UserActivityDetector::PreHandleKeyEvent(aura::Window* target,
 
 bool UserActivityDetector::PreHandleMouseEvent(aura::Window* target,
                                                aura::MouseEvent* event) {
-  MaybeNotify();
+  if (!(event->flags() & ui::EF_IS_SYNTHESIZED))
+    MaybeNotify();
   return false;
 }
 
@@ -51,7 +53,8 @@ ui::GestureStatus UserActivityDetector::PreHandleGestureEvent(
 }
 
 void UserActivityDetector::MaybeNotify() {
-  base::TimeTicks now = base::TimeTicks::Now();
+  base::TimeTicks now =
+      !now_for_test_.is_null() ? now_for_test_ : base::TimeTicks::Now();
   if (last_observer_notification_time_.is_null() ||
       (now - last_observer_notification_time_).InSecondsF() >=
       kNotifyIntervalSec) {
project: Chrome
project_after: 10b688f204a81d8447c83021624220607353552e
project_before: 47cadc4c09a3732a47efdb561cd6555735487841
vul: 1
vul_func_with_fix:  bool UserActivityDetector::PreHandleMouseEvent(aura::Window* target,
                                                aura::MouseEvent* event) {
//flaw_line_below:
  MaybeNotify();
//fix_flaw_line_below:
//  if (!(event->flags() & ui::EF_IS_SYNTHESIZED))
//fix_flaw_line_below:
//    MaybeNotify();
   return false;
 }


========================================

Entry ID: 184492
: 184492
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2012-2872
CVE Page: https://www.cvedetails.com/cve/CVE-2012-2872/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2012-08-31
Score: 4.3
Summary: Cross-site scripting (XSS) vulnerability in an SSL interstitial page in Google Chrome before 21.0.1180.89 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.
Update Date: 2018-10-30
Vulnerability Classification: XSS 
add_lines: 3
codeLink: https://github.com/chromium/chromium/commit/68b6502084af7e2021f7321633f5fbb5f997a58b
commit_id: 68b6502084af7e2021f7321633f5fbb5f997a58b
commit_message: Properly EscapeForHTML potentially malicious input from X.509 certificates.

BUG=142956

TEST=Create an X.509 certificate with a CN field that contains JavaScript.
When you get the SSL error screen, check that the HTML + JavaScript is
escape instead of being treated as HTML and/or script.

Review URL: https://chromiumcodereview.appspot.com/10827364

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@152210 0039d316-1c4b-4281-b951-d872f2087c98
del_lines: 2
file_name: chrome/browser/ssl/ssl_error_info.cc
files_changed: {"sha": "d33960e55ff85b6899415bd0be1f0f9e14daca04", "filename": "chrome/browser/ssl/ssl_error_info.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/chromium/chromium/blob/68b6502084af7e2021f7321633f5fbb5f997a58b/chrome/browser/ssl/ssl_error_info.cc", "raw_url": "https://github.com/chromium/chromium/raw/68b6502084af7e2021f7321633f5fbb5f997a58b/chrome/browser/ssl/ssl_error_info.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ssl/ssl_error_info.cc?ref=68b6502084af7e2021f7321633f5fbb5f997a58b", "patch": "@@ -12,6 +12,7 @@\n #include \"grit/chromium_strings.h\"\n #include \"grit/generated_resources.h\"\n #include \"net/base/cert_status_flags.h\"\n+#include \"net/base/escape.h\"\n #include \"net/base/net_errors.h\"\n #include \"net/base/ssl_info.h\"\n #include \"ui/base/l10n/l10n_util.h\"\n@@ -55,7 +56,8 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,\n       details =\n           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,\n                                      UTF8ToUTF16(request_url.host()),\n-                                     UTF8ToUTF16(dns_names[i]),\n+                                     net::EscapeForHTML(\n+                                         UTF8ToUTF16(dns_names[i])),\n                                      UTF8ToUTF16(request_url.host()));\n       short_description = l10n_util::GetStringUTF16(\n           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);\n@@ -64,7 +66,7 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,\n       extra_info.push_back(\n           l10n_util::GetStringFUTF16(\n               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,\n-              UTF8ToUTF16(cert->subject().common_name),\n+              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),\n               UTF8ToUTF16(request_url.host())));\n       break;\n     }"}
func_after: SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
                                     net::EscapeForHTML(
                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}

func_before: SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
                                     UTF8ToUTF16(dns_names[i]),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
              UTF8ToUTF16(cert->subject().common_name),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}

lang: C
lines_after:                                      net::EscapeForHTML(
                                         UTF8ToUTF16(dns_names[i])),
              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),

lines_before:                                      UTF8ToUTF16(dns_names[i]),
              UTF8ToUTF16(cert->subject().common_name),

parentID: 
patch: @@ -12,6 +12,7 @@
 #include "grit/chromium_strings.h"
 #include "grit/generated_resources.h"
 #include "net/base/cert_status_flags.h"
+#include "net/base/escape.h"
 #include "net/base/net_errors.h"
 #include "net/base/ssl_info.h"
 #include "ui/base/l10n/l10n_util.h"
@@ -55,7 +56,8 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
-                                     UTF8ToUTF16(dns_names[i]),
+                                     net::EscapeForHTML(
+                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
@@ -64,7 +66,7 @@ SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
-              UTF8ToUTF16(cert->subject().common_name),
+              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }
project: Chrome
project_after: 68b6502084af7e2021f7321633f5fbb5f997a58b
project_before: 4150ecc30d10d0f211033346f10611e3c6083160
vul: 1
vul_func_with_fix: SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
                                       net::X509Certificate* cert,
                                       const GURL& request_url) {
  string16 title, details, short_description;
  std::vector<string16> extra_info;
  switch (error_type) {
    case CERT_COMMON_NAME_INVALID: {
      title =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_TITLE);
      // If the certificate contains multiple DNS names, we choose the most
      // representative one -- either the DNS name that's also in the subject
      // field, or the first one.  If this heuristic turns out to be
      // inadequate, we can consider choosing the DNS name that is the
      // "closest match" to the host name in the request URL, or listing all
      // the DNS names with an HTML <ul>.
      std::vector<std::string> dns_names;
      cert->GetDNSNames(&dns_names);
      DCHECK(!dns_names.empty());
      size_t i = 0;
      for (; i < dns_names.size(); ++i) {
        if (dns_names[i] == cert->subject().common_name)
          break;
      }
      if (i == dns_names.size())
        i = 0;
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
//flaw_line_below:
                                     UTF8ToUTF16(dns_names[i]),
//fix_flaw_line_below:
//                                     net::EscapeForHTML(
//fix_flaw_line_below:
//                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
//flaw_line_below:
              UTF8ToUTF16(cert->subject().common_name),
//fix_flaw_line_below:
//              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }
    case CERT_DATE_INVALID:
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      if (cert->HasExpired()) {
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXPIRED_DESCRIPTION);
        extra_info.push_back(l10n_util::GetStringUTF16(
            IDS_CERT_ERROR_EXPIRED_DETAILS_EXTRA_INFO_2));
      } else {
        // Then it must be not yet valid.  We don't check that it is not yet
        // valid as there is still a very unlikely chance that the cert might
        // have become valid since the error occurred.
        title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_TITLE);
        details = l10n_util::GetStringFUTF16(
            IDS_CERT_ERROR_NOT_YET_VALID_DETAILS,
            UTF8ToUTF16(request_url.host()),
            UTF8ToUTF16(request_url.host()),
            base::TimeFormatFriendlyDateAndTime(base::Time::Now()));
        short_description =
            l10n_util::GetStringUTF16(IDS_CERT_ERROR_NOT_YET_VALID_DESCRIPTION);
        extra_info.push_back(
            l10n_util::GetStringUTF16(
                IDS_CERT_ERROR_NOT_YET_VALID_DETAILS_EXTRA_INFO_2));
      }
      break;
    case CERT_AUTHORITY_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_AUTHORITY_INVALID_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_2,
          UTF8ToUTF16(request_url.host()),
          UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_AUTHORITY_INVALID_EXTRA_INFO_3));
      break;
    case CERT_CONTAINS_ERRORS:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_CONTAINS_ERRORS_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringFUTF16(IDS_CERT_ERROR_EXTRA_INFO_1,
                                     UTF8ToUTF16(request_url.host())));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_CONTAINS_ERRORS_EXTRA_INFO_2));
      break;
    case CERT_NO_REVOCATION_MECHANISM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_NO_REVOCATION_MECHANISM_DESCRIPTION);
      break;
    case CERT_UNABLE_TO_CHECK_REVOCATION:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_TITLE);
      details = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DETAILS);
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_UNABLE_TO_CHECK_REVOCATION_DESCRIPTION);
      break;
    case CERT_REVOKED:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(IDS_CERT_ERROR_REVOKED_CERT_DETAILS,
                                           UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_REVOKED_CERT_EXTRA_INFO_2));
      break;
    case CERT_INVALID:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_INVALID_CERT_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_INVALID_CERT_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_INVALID_CERT_EXTRA_INFO_2));
      break;
    case CERT_WEAK_SIGNATURE_ALGORITHM:
      title = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DETAILS,
          UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_SIGNATURE_ALGORITHM_EXTRA_INFO_2));
      break;
    case CERT_WEAK_KEY:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_WEAK_KEY_TITLE);
      details = l10n_util::GetStringFUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DETAILS, UTF8ToUTF16(request_url.host()));
      short_description = l10n_util::GetStringUTF16(
          IDS_CERT_ERROR_WEAK_KEY_DESCRIPTION);
      extra_info.push_back(
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_EXTRA_INFO_1));
      extra_info.push_back(
          l10n_util::GetStringUTF16(
              IDS_CERT_ERROR_WEAK_KEY_EXTRA_INFO_2));
      break;
    case UNKNOWN:
      title = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_TITLE);
      details = l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DETAILS);
      short_description =
          l10n_util::GetStringUTF16(IDS_CERT_ERROR_UNKNOWN_ERROR_DESCRIPTION);
      break;
    default:
      NOTREACHED();
  }
  return SSLErrorInfo(title, details, short_description, extra_info);
}


========================================

Entry ID: 185326
: 185326
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2014-1747
CVE Page: https://www.cvedetails.com/cve/CVE-2014-1747/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2014-05-21
Score: 4.3
Summary: Cross-site scripting (XSS) vulnerability in the DocumentLoader::maybeCreateArchive function in core/loader/DocumentLoader.cpp in Blink, as used in Google Chrome before 35.0.1916.114, allows remote attackers to inject arbitrary web script or HTML via crafted MHTML content, aka *Universal XSS (UXSS).*
Update Date: 2017-12-28
Vulnerability Classification: XSS 
add_lines: 1
codeLink: https://github.com/chromium/chromium/commit/1924f747637265f563892b8f56a64391f6208194
commit_id: 1924f747637265f563892b8f56a64391f6208194
commit_message: Allow the cast tray to function as expected when the installed extension is missing API methods.

BUG=489445

Review URL: https://codereview.chromium.org/1145833003

Cr-Commit-Position: refs/heads/master@{#330663}
del_lines: 1
file_name: ash/system/cast/tray_cast.cc
files_changed: {"sha": "d997e0c26bfef095d87be8c1d343ac30cee969a8", "filename": "ash/ash_strings.grd", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/ash_strings.grd?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -278,6 +278,12 @@ Press Ctrl+Alt+Z to disable.\n       <message name=\"IDS_ASH_STATUS_TRAY_CAST_STOP\" desc=\"The label used in the tray popup to stop casting.\">\n         Stop\n       </message>\n+      <message name=\"IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE\" desc=\"The label used when we have detected we are casting but do not know if we are casting a tab or the desktop.\">\n+        Casting\n+      </message>\n+      <message name=\"IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER\" desc=\"The label used when we have detected we are casting but do not know the name of the receiver.\">\n+        Unknown receiver\n+      </message>\n \n       <message name=\"IDS_ASH_STATUS_TRAY_BLUETOOTH\" desc=\"The label used as the header in the bluetooth popup.\">\n         Bluetooth"}<_**next**_>{"sha": "f38a05c5f3f6322ad00a77f7b24d61a6916f6fbb", "filename": "ash/cast_config_delegate.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/cast_config_delegate.h?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -83,13 +83,8 @@ class CastConfigDelegate {\n   // Cast to a receiver specified by |receiver_id|.\n   virtual void CastToReceiver(const std::string& receiver_id) = 0;\n \n-  // Stop ongoing cast. The |activity_id| is the unique identifier associated\n-  // with the ongoing cast. Each receiver has only one possible activity\n-  // associated with it. The |activity_id| is available by invoking\n-  // GetReceiversAndActivities(); if the receiver is currently casting, then the\n-  // associated activity data will have an id. This id can be used to stop the\n-  // cast in this method.\n-  virtual void StopCasting(const std::string& activity_id) = 0;\n+  // Stop an ongoing cast.\n+  virtual void StopCasting() = 0;\n \n   // Opens Options page for cast.\n   virtual void LaunchCastOptions() = 0;"}<_**next**_>{"sha": "355eb404d27750dfe60dce19869fdb21fcc125be", "filename": "ash/system/cast/tray_cast.cc", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/system/cast/tray_cast.cc?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -38,28 +38,6 @@ namespace ash {\n \n namespace {\n const int kStopButtonRightPadding = 18;\n-\n-// Callback helper for StopCast().\n-void StopCastCallback(\n-    CastConfigDelegate* cast_config,\n-    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {\n-  for (auto& item : receivers_activities) {\n-    CastConfigDelegate::Activity activity = item.second.activity;\n-    if (activity.allow_stop && activity.id.empty() == false)\n-      cast_config->StopCasting(activity.id);\n-  }\n-}\n-\n-// Stops currently casting device.\n-void StopCast() {\n-  CastConfigDelegate* cast_config =\n-      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();\n-  if (cast_config && cast_config->HasCastExtension()) {\n-    cast_config->GetReceiversAndActivities(\n-        base::Bind(&StopCastCallback, cast_config));\n-  }\n-}\n-\n }  // namespace\n \n namespace tray {\n@@ -182,12 +160,16 @@ CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)\n   title_ = new views::Label;\n   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));\n+  title_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));\n   label_container_->AddChildView(title_);\n \n   details_ = new views::Label;\n   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   details_->SetMultiLine(false);\n   details_->SetEnabledColor(kHeaderTextColorNormal);\n+  details_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));\n   label_container_->AddChildView(details_);\n \n   AddChildView(label_container_);\n@@ -270,7 +252,7 @@ void CastCastView::UpdateLabelCallback(\n void CastCastView::ButtonPressed(views::Button* sender,\n                                  const ui::Event& event) {\n   DCHECK(sender == stop_button_);\n-  StopCast();\n+  cast_config_delegate_->StopCasting();\n }\n \n // This view by itself does very little. It acts as a front-end for managing"}<_**next**_>{"sha": "9873cf404c009dd69fa9d0d8da2cd80f6a693ae2", "filename": "chrome/browser/ui/ash/cast_config_delegate_chromeos.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -138,8 +138,14 @@ void CastConfigDelegateChromeos::CastToReceiver(\n                     \"');\");\n }\n \n-void CastConfigDelegateChromeos::StopCasting(const std::string& activity_id) {\n+void CastConfigDelegateChromeos::StopCasting() {\n   ExecuteJavaScript(\"backgroundSetup.stopCastMirroring('user-stop');\");\n+\n+  // TODO(jdufault): Remove this after stopCastMirroring is properly exported.\n+  // The current beta/release versions of the cast extension do not export\n+  // stopCastMirroring, so we will also try to call the minified version.\n+  // See crbug.com/489929.\n+  ExecuteJavaScript(\"backgroundSetup.Qu('user-stop');\");\n }\n \n void CastConfigDelegateChromeos::LaunchCastOptions() {"}<_**next**_>{"sha": "c77afebdd8a45e32aa1f95a450a13bc3e575483e", "filename": "chrome/browser/ui/ash/cast_config_delegate_chromeos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.h?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -27,7 +27,7 @@ class CastConfigDelegateChromeos : public ash::CastConfigDelegate {\n   void GetReceiversAndActivities(\n       const ReceiversAndActivitesCallback& callback) override;\n   void CastToReceiver(const std::string& receiver_id) override;\n-  void StopCasting(const std::string& activity_id) override;\n+  void StopCasting() override;\n   void LaunchCastOptions() override;\n \n   DISALLOW_COPY_AND_ASSIGN(CastConfigDelegateChromeos);"}
func_after:  void CastCastView::ButtonPressed(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == stop_button_);
  cast_config_delegate_->StopCasting();
 }

func_before:  void CastCastView::ButtonPressed(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == stop_button_);
  StopCast();
 }

lang: C
lines_after:   cast_config_delegate_->StopCasting();

lines_before:   StopCast();

parentID: 
patch: @@ -38,28 +38,6 @@ namespace ash {
 
 namespace {
 const int kStopButtonRightPadding = 18;
-
-// Callback helper for StopCast().
-void StopCastCallback(
-    CastConfigDelegate* cast_config,
-    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {
-  for (auto& item : receivers_activities) {
-    CastConfigDelegate::Activity activity = item.second.activity;
-    if (activity.allow_stop && activity.id.empty() == false)
-      cast_config->StopCasting(activity.id);
-  }
-}
-
-// Stops currently casting device.
-void StopCast() {
-  CastConfigDelegate* cast_config =
-      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();
-  if (cast_config && cast_config->HasCastExtension()) {
-    cast_config->GetReceiversAndActivities(
-        base::Bind(&StopCastCallback, cast_config));
-  }
-}
-
 }  // namespace
 
 namespace tray {
@@ -182,12 +160,16 @@ CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)
   title_ = new views::Label;
   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));
+  title_->SetText(
+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));
   label_container_->AddChildView(title_);
 
   details_ = new views::Label;
   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   details_->SetMultiLine(false);
   details_->SetEnabledColor(kHeaderTextColorNormal);
+  details_->SetText(
+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));
   label_container_->AddChildView(details_);
 
   AddChildView(label_container_);
@@ -270,7 +252,7 @@ void CastCastView::UpdateLabelCallback(
 void CastCastView::ButtonPressed(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == stop_button_);
-  StopCast();
+  cast_config_delegate_->StopCasting();
 }
 
 // This view by itself does very little. It acts as a front-end for managing
project: Chrome
project_after: 1924f747637265f563892b8f56a64391f6208194
project_before: 04192cf91fe892f516854317886ae2227af0ccb5
vul: 1
vul_func_with_fix:  void CastCastView::ButtonPressed(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == stop_button_);
//flaw_line_below:
  StopCast();
//fix_flaw_line_below:
//  cast_config_delegate_->StopCasting();
 }


========================================

Entry ID: 185327
: 185327
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2014-1747
CVE Page: https://www.cvedetails.com/cve/CVE-2014-1747/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2014-05-21
Score: 4.3
Summary: Cross-site scripting (XSS) vulnerability in the DocumentLoader::maybeCreateArchive function in core/loader/DocumentLoader.cpp in Blink, as used in Google Chrome before 35.0.1916.114, allows remote attackers to inject arbitrary web script or HTML via crafted MHTML content, aka *Universal XSS (UXSS).*
Update Date: 2017-12-28
Vulnerability Classification: XSS 
add_lines: 4
codeLink: https://github.com/chromium/chromium/commit/1924f747637265f563892b8f56a64391f6208194
commit_id: 1924f747637265f563892b8f56a64391f6208194
commit_message: Allow the cast tray to function as expected when the installed extension is missing API methods.

BUG=489445

Review URL: https://codereview.chromium.org/1145833003

Cr-Commit-Position: refs/heads/master@{#330663}
del_lines: 0
file_name: ash/system/cast/tray_cast.cc
files_changed: {"sha": "d997e0c26bfef095d87be8c1d343ac30cee969a8", "filename": "ash/ash_strings.grd", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/ash_strings.grd?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -278,6 +278,12 @@ Press Ctrl+Alt+Z to disable.\n       <message name=\"IDS_ASH_STATUS_TRAY_CAST_STOP\" desc=\"The label used in the tray popup to stop casting.\">\n         Stop\n       </message>\n+      <message name=\"IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE\" desc=\"The label used when we have detected we are casting but do not know if we are casting a tab or the desktop.\">\n+        Casting\n+      </message>\n+      <message name=\"IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER\" desc=\"The label used when we have detected we are casting but do not know the name of the receiver.\">\n+        Unknown receiver\n+      </message>\n \n       <message name=\"IDS_ASH_STATUS_TRAY_BLUETOOTH\" desc=\"The label used as the header in the bluetooth popup.\">\n         Bluetooth"}<_**next**_>{"sha": "f38a05c5f3f6322ad00a77f7b24d61a6916f6fbb", "filename": "ash/cast_config_delegate.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/cast_config_delegate.h?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -83,13 +83,8 @@ class CastConfigDelegate {\n   // Cast to a receiver specified by |receiver_id|.\n   virtual void CastToReceiver(const std::string& receiver_id) = 0;\n \n-  // Stop ongoing cast. The |activity_id| is the unique identifier associated\n-  // with the ongoing cast. Each receiver has only one possible activity\n-  // associated with it. The |activity_id| is available by invoking\n-  // GetReceiversAndActivities(); if the receiver is currently casting, then the\n-  // associated activity data will have an id. This id can be used to stop the\n-  // cast in this method.\n-  virtual void StopCasting(const std::string& activity_id) = 0;\n+  // Stop an ongoing cast.\n+  virtual void StopCasting() = 0;\n \n   // Opens Options page for cast.\n   virtual void LaunchCastOptions() = 0;"}<_**next**_>{"sha": "355eb404d27750dfe60dce19869fdb21fcc125be", "filename": "ash/system/cast/tray_cast.cc", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/system/cast/tray_cast.cc?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -38,28 +38,6 @@ namespace ash {\n \n namespace {\n const int kStopButtonRightPadding = 18;\n-\n-// Callback helper for StopCast().\n-void StopCastCallback(\n-    CastConfigDelegate* cast_config,\n-    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {\n-  for (auto& item : receivers_activities) {\n-    CastConfigDelegate::Activity activity = item.second.activity;\n-    if (activity.allow_stop && activity.id.empty() == false)\n-      cast_config->StopCasting(activity.id);\n-  }\n-}\n-\n-// Stops currently casting device.\n-void StopCast() {\n-  CastConfigDelegate* cast_config =\n-      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();\n-  if (cast_config && cast_config->HasCastExtension()) {\n-    cast_config->GetReceiversAndActivities(\n-        base::Bind(&StopCastCallback, cast_config));\n-  }\n-}\n-\n }  // namespace\n \n namespace tray {\n@@ -182,12 +160,16 @@ CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)\n   title_ = new views::Label;\n   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));\n+  title_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));\n   label_container_->AddChildView(title_);\n \n   details_ = new views::Label;\n   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   details_->SetMultiLine(false);\n   details_->SetEnabledColor(kHeaderTextColorNormal);\n+  details_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));\n   label_container_->AddChildView(details_);\n \n   AddChildView(label_container_);\n@@ -270,7 +252,7 @@ void CastCastView::UpdateLabelCallback(\n void CastCastView::ButtonPressed(views::Button* sender,\n                                  const ui::Event& event) {\n   DCHECK(sender == stop_button_);\n-  StopCast();\n+  cast_config_delegate_->StopCasting();\n }\n \n // This view by itself does very little. It acts as a front-end for managing"}<_**next**_>{"sha": "9873cf404c009dd69fa9d0d8da2cd80f6a693ae2", "filename": "chrome/browser/ui/ash/cast_config_delegate_chromeos.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -138,8 +138,14 @@ void CastConfigDelegateChromeos::CastToReceiver(\n                     \"');\");\n }\n \n-void CastConfigDelegateChromeos::StopCasting(const std::string& activity_id) {\n+void CastConfigDelegateChromeos::StopCasting() {\n   ExecuteJavaScript(\"backgroundSetup.stopCastMirroring('user-stop');\");\n+\n+  // TODO(jdufault): Remove this after stopCastMirroring is properly exported.\n+  // The current beta/release versions of the cast extension do not export\n+  // stopCastMirroring, so we will also try to call the minified version.\n+  // See crbug.com/489929.\n+  ExecuteJavaScript(\"backgroundSetup.Qu('user-stop');\");\n }\n \n void CastConfigDelegateChromeos::LaunchCastOptions() {"}<_**next**_>{"sha": "c77afebdd8a45e32aa1f95a450a13bc3e575483e", "filename": "chrome/browser/ui/ash/cast_config_delegate_chromeos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.h?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -27,7 +27,7 @@ class CastConfigDelegateChromeos : public ash::CastConfigDelegate {\n   void GetReceiversAndActivities(\n       const ReceiversAndActivitesCallback& callback) override;\n   void CastToReceiver(const std::string& receiver_id) override;\n-  void StopCasting(const std::string& activity_id) override;\n+  void StopCasting() override;\n   void LaunchCastOptions() override;\n \n   DISALLOW_COPY_AND_ASSIGN(CastConfigDelegateChromeos);"}
func_after: CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)
    : cast_config_delegate_(cast_config_delegate) {

  set_background(views::Background::CreateSolidBackground(kBackgroundColor));
  ui::ResourceBundle& bundle = ui::ResourceBundle::GetSharedInstance();
  SetLayoutManager(new views::BoxLayout(views::BoxLayout::kHorizontal,
                                        kTrayPopupPaddingHorizontal, 0,
                                        kTrayPopupPaddingBetweenItems));
  icon_ = new FixedSizedImageView(0, kTrayPopupItemHeight);
  icon_->SetImage(
      bundle.GetImageNamed(IDR_AURA_UBER_TRAY_CAST_ENABLED).ToImageSkia());
  AddChildView(icon_);

  label_container_ = new views::View;
  label_container_->SetLayoutManager(
      new views::BoxLayout(views::BoxLayout::kVertical, 0, 0, 0));

   title_ = new views::Label;
   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));
  title_->SetText(
      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));
   label_container_->AddChildView(title_);
 
   details_ = new views::Label;
   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   details_->SetMultiLine(false);
   details_->SetEnabledColor(kHeaderTextColorNormal);
  details_->SetText(
      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));
   label_container_->AddChildView(details_);
 
   AddChildView(label_container_);

  base::string16 stop_button_text =
      ui::ResourceBundle::GetSharedInstance().GetLocalizedString(
          IDS_ASH_STATUS_TRAY_CAST_STOP);
  stop_button_ = new TrayPopupLabelButton(this, stop_button_text);
  AddChildView(stop_button_);

  UpdateLabel();
}

func_before: CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)
    : cast_config_delegate_(cast_config_delegate) {

  set_background(views::Background::CreateSolidBackground(kBackgroundColor));
  ui::ResourceBundle& bundle = ui::ResourceBundle::GetSharedInstance();
  SetLayoutManager(new views::BoxLayout(views::BoxLayout::kHorizontal,
                                        kTrayPopupPaddingHorizontal, 0,
                                        kTrayPopupPaddingBetweenItems));
  icon_ = new FixedSizedImageView(0, kTrayPopupItemHeight);
  icon_->SetImage(
      bundle.GetImageNamed(IDR_AURA_UBER_TRAY_CAST_ENABLED).ToImageSkia());
  AddChildView(icon_);

  label_container_ = new views::View;
  label_container_->SetLayoutManager(
      new views::BoxLayout(views::BoxLayout::kVertical, 0, 0, 0));

   title_ = new views::Label;
   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));
   label_container_->AddChildView(title_);
 
   details_ = new views::Label;
   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   details_->SetMultiLine(false);
   details_->SetEnabledColor(kHeaderTextColorNormal);
   label_container_->AddChildView(details_);
 
   AddChildView(label_container_);

  base::string16 stop_button_text =
      ui::ResourceBundle::GetSharedInstance().GetLocalizedString(
          IDS_ASH_STATUS_TRAY_CAST_STOP);
  stop_button_ = new TrayPopupLabelButton(this, stop_button_text);
  AddChildView(stop_button_);

  UpdateLabel();
}

lang: C
lines_after:   title_->SetText(
      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));
  details_->SetText(
      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));

lines_before: 
parentID: 
patch: @@ -38,28 +38,6 @@ namespace ash {
 
 namespace {
 const int kStopButtonRightPadding = 18;
-
-// Callback helper for StopCast().
-void StopCastCallback(
-    CastConfigDelegate* cast_config,
-    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {
-  for (auto& item : receivers_activities) {
-    CastConfigDelegate::Activity activity = item.second.activity;
-    if (activity.allow_stop && activity.id.empty() == false)
-      cast_config->StopCasting(activity.id);
-  }
-}
-
-// Stops currently casting device.
-void StopCast() {
-  CastConfigDelegate* cast_config =
-      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();
-  if (cast_config && cast_config->HasCastExtension()) {
-    cast_config->GetReceiversAndActivities(
-        base::Bind(&StopCastCallback, cast_config));
-  }
-}
-
 }  // namespace
 
 namespace tray {
@@ -182,12 +160,16 @@ CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)
   title_ = new views::Label;
   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));
+  title_->SetText(
+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));
   label_container_->AddChildView(title_);
 
   details_ = new views::Label;
   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   details_->SetMultiLine(false);
   details_->SetEnabledColor(kHeaderTextColorNormal);
+  details_->SetText(
+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));
   label_container_->AddChildView(details_);
 
   AddChildView(label_container_);
@@ -270,7 +252,7 @@ void CastCastView::UpdateLabelCallback(
 void CastCastView::ButtonPressed(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == stop_button_);
-  StopCast();
+  cast_config_delegate_->StopCasting();
 }
 
 // This view by itself does very little. It acts as a front-end for managing
project: Chrome
project_after: 1924f747637265f563892b8f56a64391f6208194
project_before: 04192cf91fe892f516854317886ae2227af0ccb5
vul: 1
vul_func_with_fix: CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)
    : cast_config_delegate_(cast_config_delegate) {
  // We will initialize the primary tray view which shows a stop button here.

  set_background(views::Background::CreateSolidBackground(kBackgroundColor));
  ui::ResourceBundle& bundle = ui::ResourceBundle::GetSharedInstance();
  SetLayoutManager(new views::BoxLayout(views::BoxLayout::kHorizontal,
                                        kTrayPopupPaddingHorizontal, 0,
                                        kTrayPopupPaddingBetweenItems));
  icon_ = new FixedSizedImageView(0, kTrayPopupItemHeight);
  icon_->SetImage(
      bundle.GetImageNamed(IDR_AURA_UBER_TRAY_CAST_ENABLED).ToImageSkia());
  AddChildView(icon_);

  // The view has two labels, one above the other. The top label (|title_|)
  // specifies that we are, say, "Casting desktop". The bottom label
  // (|details_|) specifies where we are casting to, ie, "SomeRandom cast"
  label_container_ = new views::View;
  label_container_->SetLayoutManager(
      new views::BoxLayout(views::BoxLayout::kVertical, 0, 0, 0));

   title_ = new views::Label;
   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));
//fix_flaw_line_below:
//  title_->SetText(
//fix_flaw_line_below:
//      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));
   label_container_->AddChildView(title_);
 
   details_ = new views::Label;
   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   details_->SetMultiLine(false);
   details_->SetEnabledColor(kHeaderTextColorNormal);
//fix_flaw_line_below:
//  details_->SetText(
//fix_flaw_line_below:
//      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));
   label_container_->AddChildView(details_);
 
   AddChildView(label_container_);

  // Add the stop bottom on the far-right. We customize how this stop button is
  // displayed inside of |Layout()|.
  base::string16 stop_button_text =
      ui::ResourceBundle::GetSharedInstance().GetLocalizedString(
          IDS_ASH_STATUS_TRAY_CAST_STOP);
  stop_button_ = new TrayPopupLabelButton(this, stop_button_text);
  AddChildView(stop_button_);

  UpdateLabel();
}


========================================

Entry ID: 185328
: 185328
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2014-1747
CVE Page: https://www.cvedetails.com/cve/CVE-2014-1747/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2014-05-21
Score: 4.3
Summary: Cross-site scripting (XSS) vulnerability in the DocumentLoader::maybeCreateArchive function in core/loader/DocumentLoader.cpp in Blink, as used in Google Chrome before 35.0.1916.114, allows remote attackers to inject arbitrary web script or HTML via crafted MHTML content, aka *Universal XSS (UXSS).*
Update Date: 2017-12-28
Vulnerability Classification: XSS 
add_lines: 0
codeLink: https://github.com/chromium/chromium/commit/1924f747637265f563892b8f56a64391f6208194
commit_id: 1924f747637265f563892b8f56a64391f6208194
commit_message: Allow the cast tray to function as expected when the installed extension is missing API methods.

BUG=489445

Review URL: https://codereview.chromium.org/1145833003

Cr-Commit-Position: refs/heads/master@{#330663}
del_lines: 7
file_name: ash/system/cast/tray_cast.cc
files_changed: {"sha": "d997e0c26bfef095d87be8c1d343ac30cee969a8", "filename": "ash/ash_strings.grd", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/ash_strings.grd?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -278,6 +278,12 @@ Press Ctrl+Alt+Z to disable.\n       <message name=\"IDS_ASH_STATUS_TRAY_CAST_STOP\" desc=\"The label used in the tray popup to stop casting.\">\n         Stop\n       </message>\n+      <message name=\"IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE\" desc=\"The label used when we have detected we are casting but do not know if we are casting a tab or the desktop.\">\n+        Casting\n+      </message>\n+      <message name=\"IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER\" desc=\"The label used when we have detected we are casting but do not know the name of the receiver.\">\n+        Unknown receiver\n+      </message>\n \n       <message name=\"IDS_ASH_STATUS_TRAY_BLUETOOTH\" desc=\"The label used as the header in the bluetooth popup.\">\n         Bluetooth"}<_**next**_>{"sha": "f38a05c5f3f6322ad00a77f7b24d61a6916f6fbb", "filename": "ash/cast_config_delegate.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/cast_config_delegate.h?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -83,13 +83,8 @@ class CastConfigDelegate {\n   // Cast to a receiver specified by |receiver_id|.\n   virtual void CastToReceiver(const std::string& receiver_id) = 0;\n \n-  // Stop ongoing cast. The |activity_id| is the unique identifier associated\n-  // with the ongoing cast. Each receiver has only one possible activity\n-  // associated with it. The |activity_id| is available by invoking\n-  // GetReceiversAndActivities(); if the receiver is currently casting, then the\n-  // associated activity data will have an id. This id can be used to stop the\n-  // cast in this method.\n-  virtual void StopCasting(const std::string& activity_id) = 0;\n+  // Stop an ongoing cast.\n+  virtual void StopCasting() = 0;\n \n   // Opens Options page for cast.\n   virtual void LaunchCastOptions() = 0;"}<_**next**_>{"sha": "355eb404d27750dfe60dce19869fdb21fcc125be", "filename": "ash/system/cast/tray_cast.cc", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/system/cast/tray_cast.cc?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -38,28 +38,6 @@ namespace ash {\n \n namespace {\n const int kStopButtonRightPadding = 18;\n-\n-// Callback helper for StopCast().\n-void StopCastCallback(\n-    CastConfigDelegate* cast_config,\n-    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {\n-  for (auto& item : receivers_activities) {\n-    CastConfigDelegate::Activity activity = item.second.activity;\n-    if (activity.allow_stop && activity.id.empty() == false)\n-      cast_config->StopCasting(activity.id);\n-  }\n-}\n-\n-// Stops currently casting device.\n-void StopCast() {\n-  CastConfigDelegate* cast_config =\n-      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();\n-  if (cast_config && cast_config->HasCastExtension()) {\n-    cast_config->GetReceiversAndActivities(\n-        base::Bind(&StopCastCallback, cast_config));\n-  }\n-}\n-\n }  // namespace\n \n namespace tray {\n@@ -182,12 +160,16 @@ CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)\n   title_ = new views::Label;\n   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));\n+  title_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));\n   label_container_->AddChildView(title_);\n \n   details_ = new views::Label;\n   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   details_->SetMultiLine(false);\n   details_->SetEnabledColor(kHeaderTextColorNormal);\n+  details_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));\n   label_container_->AddChildView(details_);\n \n   AddChildView(label_container_);\n@@ -270,7 +252,7 @@ void CastCastView::UpdateLabelCallback(\n void CastCastView::ButtonPressed(views::Button* sender,\n                                  const ui::Event& event) {\n   DCHECK(sender == stop_button_);\n-  StopCast();\n+  cast_config_delegate_->StopCasting();\n }\n \n // This view by itself does very little. It acts as a front-end for managing"}<_**next**_>{"sha": "9873cf404c009dd69fa9d0d8da2cd80f6a693ae2", "filename": "chrome/browser/ui/ash/cast_config_delegate_chromeos.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -138,8 +138,14 @@ void CastConfigDelegateChromeos::CastToReceiver(\n                     \"');\");\n }\n \n-void CastConfigDelegateChromeos::StopCasting(const std::string& activity_id) {\n+void CastConfigDelegateChromeos::StopCasting() {\n   ExecuteJavaScript(\"backgroundSetup.stopCastMirroring('user-stop');\");\n+\n+  // TODO(jdufault): Remove this after stopCastMirroring is properly exported.\n+  // The current beta/release versions of the cast extension do not export\n+  // stopCastMirroring, so we will also try to call the minified version.\n+  // See crbug.com/489929.\n+  ExecuteJavaScript(\"backgroundSetup.Qu('user-stop');\");\n }\n \n void CastConfigDelegateChromeos::LaunchCastOptions() {"}<_**next**_>{"sha": "c77afebdd8a45e32aa1f95a450a13bc3e575483e", "filename": "chrome/browser/ui/ash/cast_config_delegate_chromeos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.h?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -27,7 +27,7 @@ class CastConfigDelegateChromeos : public ash::CastConfigDelegate {\n   void GetReceiversAndActivities(\n       const ReceiversAndActivitesCallback& callback) override;\n   void CastToReceiver(const std::string& receiver_id) override;\n-  void StopCasting(const std::string& activity_id) override;\n+  void StopCasting() override;\n   void LaunchCastOptions() override;\n \n   DISALLOW_COPY_AND_ASSIGN(CastConfigDelegateChromeos);"}
func_after: void StopCast() {

func_before: void StopCast() {
  CastConfigDelegate* cast_config =
      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();
  if (cast_config && cast_config->HasCastExtension()) {
    cast_config->GetReceiversAndActivities(
        base::Bind(&StopCastCallback, cast_config));
  }
}

lang: C
lines_after: 
lines_before:   CastConfigDelegate* cast_config =
      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();
  if (cast_config && cast_config->HasCastExtension()) {
    cast_config->GetReceiversAndActivities(
        base::Bind(&StopCastCallback, cast_config));
  }
}

parentID: 
patch: @@ -38,28 +38,6 @@ namespace ash {
 
 namespace {
 const int kStopButtonRightPadding = 18;
-
-// Callback helper for StopCast().
-void StopCastCallback(
-    CastConfigDelegate* cast_config,
-    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {
-  for (auto& item : receivers_activities) {
-    CastConfigDelegate::Activity activity = item.second.activity;
-    if (activity.allow_stop && activity.id.empty() == false)
-      cast_config->StopCasting(activity.id);
-  }
-}
-
-// Stops currently casting device.
-void StopCast() {
-  CastConfigDelegate* cast_config =
-      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();
-  if (cast_config && cast_config->HasCastExtension()) {
-    cast_config->GetReceiversAndActivities(
-        base::Bind(&StopCastCallback, cast_config));
-  }
-}
-
 }  // namespace
 
 namespace tray {
@@ -182,12 +160,16 @@ CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)
   title_ = new views::Label;
   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));
+  title_->SetText(
+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));
   label_container_->AddChildView(title_);
 
   details_ = new views::Label;
   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   details_->SetMultiLine(false);
   details_->SetEnabledColor(kHeaderTextColorNormal);
+  details_->SetText(
+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));
   label_container_->AddChildView(details_);
 
   AddChildView(label_container_);
@@ -270,7 +252,7 @@ void CastCastView::UpdateLabelCallback(
 void CastCastView::ButtonPressed(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == stop_button_);
-  StopCast();
+  cast_config_delegate_->StopCasting();
 }
 
 // This view by itself does very little. It acts as a front-end for managing
project: Chrome
project_after: 1924f747637265f563892b8f56a64391f6208194
project_before: 04192cf91fe892f516854317886ae2227af0ccb5
vul: 1
vul_func_with_fix: void StopCast() {
//flaw_line_below:
  CastConfigDelegate* cast_config =
//flaw_line_below:
      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();
//flaw_line_below:
  if (cast_config && cast_config->HasCastExtension()) {
//flaw_line_below:
    cast_config->GetReceiversAndActivities(
//flaw_line_below:
        base::Bind(&StopCastCallback, cast_config));
//flaw_line_below:
  }
//flaw_line_below:
}


========================================

Entry ID: 185329
: 185329
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2014-1747
CVE Page: https://www.cvedetails.com/cve/CVE-2014-1747/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2014-05-21
Score: 4.3
Summary: Cross-site scripting (XSS) vulnerability in the DocumentLoader::maybeCreateArchive function in core/loader/DocumentLoader.cpp in Blink, as used in Google Chrome before 35.0.1916.114, allows remote attackers to inject arbitrary web script or HTML via crafted MHTML content, aka *Universal XSS (UXSS).*
Update Date: 2017-12-28
Vulnerability Classification: XSS 
add_lines: 0
codeLink: https://github.com/chromium/chromium/commit/1924f747637265f563892b8f56a64391f6208194
commit_id: 1924f747637265f563892b8f56a64391f6208194
commit_message: Allow the cast tray to function as expected when the installed extension is missing API methods.

BUG=489445

Review URL: https://codereview.chromium.org/1145833003

Cr-Commit-Position: refs/heads/master@{#330663}
del_lines: 8
file_name: ash/system/cast/tray_cast.cc
files_changed: {"sha": "d997e0c26bfef095d87be8c1d343ac30cee969a8", "filename": "ash/ash_strings.grd", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/ash_strings.grd?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -278,6 +278,12 @@ Press Ctrl+Alt+Z to disable.\n       <message name=\"IDS_ASH_STATUS_TRAY_CAST_STOP\" desc=\"The label used in the tray popup to stop casting.\">\n         Stop\n       </message>\n+      <message name=\"IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE\" desc=\"The label used when we have detected we are casting but do not know if we are casting a tab or the desktop.\">\n+        Casting\n+      </message>\n+      <message name=\"IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER\" desc=\"The label used when we have detected we are casting but do not know the name of the receiver.\">\n+        Unknown receiver\n+      </message>\n \n       <message name=\"IDS_ASH_STATUS_TRAY_BLUETOOTH\" desc=\"The label used as the header in the bluetooth popup.\">\n         Bluetooth"}<_**next**_>{"sha": "f38a05c5f3f6322ad00a77f7b24d61a6916f6fbb", "filename": "ash/cast_config_delegate.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/cast_config_delegate.h?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -83,13 +83,8 @@ class CastConfigDelegate {\n   // Cast to a receiver specified by |receiver_id|.\n   virtual void CastToReceiver(const std::string& receiver_id) = 0;\n \n-  // Stop ongoing cast. The |activity_id| is the unique identifier associated\n-  // with the ongoing cast. Each receiver has only one possible activity\n-  // associated with it. The |activity_id| is available by invoking\n-  // GetReceiversAndActivities(); if the receiver is currently casting, then the\n-  // associated activity data will have an id. This id can be used to stop the\n-  // cast in this method.\n-  virtual void StopCasting(const std::string& activity_id) = 0;\n+  // Stop an ongoing cast.\n+  virtual void StopCasting() = 0;\n \n   // Opens Options page for cast.\n   virtual void LaunchCastOptions() = 0;"}<_**next**_>{"sha": "355eb404d27750dfe60dce19869fdb21fcc125be", "filename": "ash/system/cast/tray_cast.cc", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/system/cast/tray_cast.cc?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -38,28 +38,6 @@ namespace ash {\n \n namespace {\n const int kStopButtonRightPadding = 18;\n-\n-// Callback helper for StopCast().\n-void StopCastCallback(\n-    CastConfigDelegate* cast_config,\n-    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {\n-  for (auto& item : receivers_activities) {\n-    CastConfigDelegate::Activity activity = item.second.activity;\n-    if (activity.allow_stop && activity.id.empty() == false)\n-      cast_config->StopCasting(activity.id);\n-  }\n-}\n-\n-// Stops currently casting device.\n-void StopCast() {\n-  CastConfigDelegate* cast_config =\n-      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();\n-  if (cast_config && cast_config->HasCastExtension()) {\n-    cast_config->GetReceiversAndActivities(\n-        base::Bind(&StopCastCallback, cast_config));\n-  }\n-}\n-\n }  // namespace\n \n namespace tray {\n@@ -182,12 +160,16 @@ CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)\n   title_ = new views::Label;\n   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));\n+  title_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));\n   label_container_->AddChildView(title_);\n \n   details_ = new views::Label;\n   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   details_->SetMultiLine(false);\n   details_->SetEnabledColor(kHeaderTextColorNormal);\n+  details_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));\n   label_container_->AddChildView(details_);\n \n   AddChildView(label_container_);\n@@ -270,7 +252,7 @@ void CastCastView::UpdateLabelCallback(\n void CastCastView::ButtonPressed(views::Button* sender,\n                                  const ui::Event& event) {\n   DCHECK(sender == stop_button_);\n-  StopCast();\n+  cast_config_delegate_->StopCasting();\n }\n \n // This view by itself does very little. It acts as a front-end for managing"}<_**next**_>{"sha": "9873cf404c009dd69fa9d0d8da2cd80f6a693ae2", "filename": "chrome/browser/ui/ash/cast_config_delegate_chromeos.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -138,8 +138,14 @@ void CastConfigDelegateChromeos::CastToReceiver(\n                     \"');\");\n }\n \n-void CastConfigDelegateChromeos::StopCasting(const std::string& activity_id) {\n+void CastConfigDelegateChromeos::StopCasting() {\n   ExecuteJavaScript(\"backgroundSetup.stopCastMirroring('user-stop');\");\n+\n+  // TODO(jdufault): Remove this after stopCastMirroring is properly exported.\n+  // The current beta/release versions of the cast extension do not export\n+  // stopCastMirroring, so we will also try to call the minified version.\n+  // See crbug.com/489929.\n+  ExecuteJavaScript(\"backgroundSetup.Qu('user-stop');\");\n }\n \n void CastConfigDelegateChromeos::LaunchCastOptions() {"}<_**next**_>{"sha": "c77afebdd8a45e32aa1f95a450a13bc3e575483e", "filename": "chrome/browser/ui/ash/cast_config_delegate_chromeos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.h?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -27,7 +27,7 @@ class CastConfigDelegateChromeos : public ash::CastConfigDelegate {\n   void GetReceiversAndActivities(\n       const ReceiversAndActivitesCallback& callback) override;\n   void CastToReceiver(const std::string& receiver_id) override;\n-  void StopCasting(const std::string& activity_id) override;\n+  void StopCasting() override;\n   void LaunchCastOptions() override;\n \n   DISALLOW_COPY_AND_ASSIGN(CastConfigDelegateChromeos);"}
func_after: void StopCastCallback(

func_before: void StopCastCallback(
    CastConfigDelegate* cast_config,
    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {
  for (auto& item : receivers_activities) {
    CastConfigDelegate::Activity activity = item.second.activity;
    if (activity.allow_stop && activity.id.empty() == false)
      cast_config->StopCasting(activity.id);
  }
}

lang: C
lines_after: 
lines_before:     CastConfigDelegate* cast_config,
    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {
  for (auto& item : receivers_activities) {
    CastConfigDelegate::Activity activity = item.second.activity;
    if (activity.allow_stop && activity.id.empty() == false)
      cast_config->StopCasting(activity.id);
  }
}

parentID: 
patch: @@ -38,28 +38,6 @@ namespace ash {
 
 namespace {
 const int kStopButtonRightPadding = 18;
-
-// Callback helper for StopCast().
-void StopCastCallback(
-    CastConfigDelegate* cast_config,
-    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {
-  for (auto& item : receivers_activities) {
-    CastConfigDelegate::Activity activity = item.second.activity;
-    if (activity.allow_stop && activity.id.empty() == false)
-      cast_config->StopCasting(activity.id);
-  }
-}
-
-// Stops currently casting device.
-void StopCast() {
-  CastConfigDelegate* cast_config =
-      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();
-  if (cast_config && cast_config->HasCastExtension()) {
-    cast_config->GetReceiversAndActivities(
-        base::Bind(&StopCastCallback, cast_config));
-  }
-}
-
 }  // namespace
 
 namespace tray {
@@ -182,12 +160,16 @@ CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)
   title_ = new views::Label;
   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));
+  title_->SetText(
+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));
   label_container_->AddChildView(title_);
 
   details_ = new views::Label;
   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
   details_->SetMultiLine(false);
   details_->SetEnabledColor(kHeaderTextColorNormal);
+  details_->SetText(
+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));
   label_container_->AddChildView(details_);
 
   AddChildView(label_container_);
@@ -270,7 +252,7 @@ void CastCastView::UpdateLabelCallback(
 void CastCastView::ButtonPressed(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == stop_button_);
-  StopCast();
+  cast_config_delegate_->StopCasting();
 }
 
 // This view by itself does very little. It acts as a front-end for managing
project: Chrome
project_after: 1924f747637265f563892b8f56a64391f6208194
project_before: 04192cf91fe892f516854317886ae2227af0ccb5
vul: 1
vul_func_with_fix: void StopCastCallback(
//flaw_line_below:
    CastConfigDelegate* cast_config,
//flaw_line_below:
    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {
//flaw_line_below:
  for (auto& item : receivers_activities) {
//flaw_line_below:
    CastConfigDelegate::Activity activity = item.second.activity;
//flaw_line_below:
    if (activity.allow_stop && activity.id.empty() == false)
//flaw_line_below:
      cast_config->StopCasting(activity.id);
//flaw_line_below:
  }
//flaw_line_below:
}


========================================

Entry ID: 185330
: 185330
Access Gained: None
Attack Origin: Remote
Authentication Required: Not required
Availability: None
CVE ID: CVE-2014-1747
CVE Page: https://www.cvedetails.com/cve/CVE-2014-1747/
CWE ID: CWE-79
Complexity: Medium
Confidentiality: None
Integrity: Partial
Known Exploits: 
Publish Date: 2014-05-21
Score: 4.3
Summary: Cross-site scripting (XSS) vulnerability in the DocumentLoader::maybeCreateArchive function in core/loader/DocumentLoader.cpp in Blink, as used in Google Chrome before 35.0.1916.114, allows remote attackers to inject arbitrary web script or HTML via crafted MHTML content, aka *Universal XSS (UXSS).*
Update Date: 2017-12-28
Vulnerability Classification: XSS 
add_lines: 7
codeLink: https://github.com/chromium/chromium/commit/1924f747637265f563892b8f56a64391f6208194
commit_id: 1924f747637265f563892b8f56a64391f6208194
commit_message: Allow the cast tray to function as expected when the installed extension is missing API methods.

BUG=489445

Review URL: https://codereview.chromium.org/1145833003

Cr-Commit-Position: refs/heads/master@{#330663}
del_lines: 0
file_name: chrome/browser/ui/ash/cast_config_delegate_chromeos.cc
files_changed: {"sha": "d997e0c26bfef095d87be8c1d343ac30cee969a8", "filename": "ash/ash_strings.grd", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/ash_strings.grd", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/ash_strings.grd?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -278,6 +278,12 @@ Press Ctrl+Alt+Z to disable.\n       <message name=\"IDS_ASH_STATUS_TRAY_CAST_STOP\" desc=\"The label used in the tray popup to stop casting.\">\n         Stop\n       </message>\n+      <message name=\"IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE\" desc=\"The label used when we have detected we are casting but do not know if we are casting a tab or the desktop.\">\n+        Casting\n+      </message>\n+      <message name=\"IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER\" desc=\"The label used when we have detected we are casting but do not know the name of the receiver.\">\n+        Unknown receiver\n+      </message>\n \n       <message name=\"IDS_ASH_STATUS_TRAY_BLUETOOTH\" desc=\"The label used as the header in the bluetooth popup.\">\n         Bluetooth"}<_**next**_>{"sha": "f38a05c5f3f6322ad00a77f7b24d61a6916f6fbb", "filename": "ash/cast_config_delegate.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/cast_config_delegate.h", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/cast_config_delegate.h?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -83,13 +83,8 @@ class CastConfigDelegate {\n   // Cast to a receiver specified by |receiver_id|.\n   virtual void CastToReceiver(const std::string& receiver_id) = 0;\n \n-  // Stop ongoing cast. The |activity_id| is the unique identifier associated\n-  // with the ongoing cast. Each receiver has only one possible activity\n-  // associated with it. The |activity_id| is available by invoking\n-  // GetReceiversAndActivities(); if the receiver is currently casting, then the\n-  // associated activity data will have an id. This id can be used to stop the\n-  // cast in this method.\n-  virtual void StopCasting(const std::string& activity_id) = 0;\n+  // Stop an ongoing cast.\n+  virtual void StopCasting() = 0;\n \n   // Opens Options page for cast.\n   virtual void LaunchCastOptions() = 0;"}<_**next**_>{"sha": "355eb404d27750dfe60dce19869fdb21fcc125be", "filename": "ash/system/cast/tray_cast.cc", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/ash/system/cast/tray_cast.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/ash/system/cast/tray_cast.cc?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -38,28 +38,6 @@ namespace ash {\n \n namespace {\n const int kStopButtonRightPadding = 18;\n-\n-// Callback helper for StopCast().\n-void StopCastCallback(\n-    CastConfigDelegate* cast_config,\n-    const CastConfigDelegate::ReceiversAndActivites& receivers_activities) {\n-  for (auto& item : receivers_activities) {\n-    CastConfigDelegate::Activity activity = item.second.activity;\n-    if (activity.allow_stop && activity.id.empty() == false)\n-      cast_config->StopCasting(activity.id);\n-  }\n-}\n-\n-// Stops currently casting device.\n-void StopCast() {\n-  CastConfigDelegate* cast_config =\n-      Shell::GetInstance()->system_tray_delegate()->GetCastConfigDelegate();\n-  if (cast_config && cast_config->HasCastExtension()) {\n-    cast_config->GetReceiversAndActivities(\n-        base::Bind(&StopCastCallback, cast_config));\n-  }\n-}\n-\n }  // namespace\n \n namespace tray {\n@@ -182,12 +160,16 @@ CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)\n   title_ = new views::Label;\n   title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));\n+  title_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));\n   label_container_->AddChildView(title_);\n \n   details_ = new views::Label;\n   details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n   details_->SetMultiLine(false);\n   details_->SetEnabledColor(kHeaderTextColorNormal);\n+  details_->SetText(\n+      bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));\n   label_container_->AddChildView(details_);\n \n   AddChildView(label_container_);\n@@ -270,7 +252,7 @@ void CastCastView::UpdateLabelCallback(\n void CastCastView::ButtonPressed(views::Button* sender,\n                                  const ui::Event& event) {\n   DCHECK(sender == stop_button_);\n-  StopCast();\n+  cast_config_delegate_->StopCasting();\n }\n \n // This view by itself does very little. It acts as a front-end for managing"}<_**next**_>{"sha": "9873cf404c009dd69fa9d0d8da2cd80f6a693ae2", "filename": "chrome/browser/ui/ash/cast_config_delegate_chromeos.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.cc?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -138,8 +138,14 @@ void CastConfigDelegateChromeos::CastToReceiver(\n                     \"');\");\n }\n \n-void CastConfigDelegateChromeos::StopCasting(const std::string& activity_id) {\n+void CastConfigDelegateChromeos::StopCasting() {\n   ExecuteJavaScript(\"backgroundSetup.stopCastMirroring('user-stop');\");\n+\n+  // TODO(jdufault): Remove this after stopCastMirroring is properly exported.\n+  // The current beta/release versions of the cast extension do not export\n+  // stopCastMirroring, so we will also try to call the minified version.\n+  // See crbug.com/489929.\n+  ExecuteJavaScript(\"backgroundSetup.Qu('user-stop');\");\n }\n \n void CastConfigDelegateChromeos::LaunchCastOptions() {"}<_**next**_>{"sha": "c77afebdd8a45e32aa1f95a450a13bc3e575483e", "filename": "chrome/browser/ui/ash/cast_config_delegate_chromeos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/chromium/chromium/blob/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h", "raw_url": "https://github.com/chromium/chromium/raw/1924f747637265f563892b8f56a64391f6208194/chrome/browser/ui/ash/cast_config_delegate_chromeos.h", "contents_url": "https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/ash/cast_config_delegate_chromeos.h?ref=1924f747637265f563892b8f56a64391f6208194", "patch": "@@ -27,7 +27,7 @@ class CastConfigDelegateChromeos : public ash::CastConfigDelegate {\n   void GetReceiversAndActivities(\n       const ReceiversAndActivitesCallback& callback) override;\n   void CastToReceiver(const std::string& receiver_id) override;\n-  void StopCasting(const std::string& activity_id) override;\n+  void StopCasting() override;\n   void LaunchCastOptions() override;\n \n   DISALLOW_COPY_AND_ASSIGN(CastConfigDelegateChromeos);"}
func_after: void CastConfigDelegateChromeos::StopCasting(const std::string& activity_id) {
void CastConfigDelegateChromeos::StopCasting() {
   ExecuteJavaScript("backgroundSetup.stopCastMirroring('user-stop');");

  // TODO(jdufault): Remove this after stopCastMirroring is properly exported.
  // The current beta/release versions of the cast extension do not export
  // stopCastMirroring, so we will also try to call the minified version.
  // See crbug.com/489929.
  ExecuteJavaScript("backgroundSetup.Qu('user-stop');");
 }

func_before: void CastConfigDelegateChromeos::StopCasting(const std::string& activity_id) {
   ExecuteJavaScript("backgroundSetup.stopCastMirroring('user-stop');");
 }

lang: C
lines_after: void CastConfigDelegateChromeos::StopCasting() {

  // TODO(jdufault): Remove this after stopCastMirroring is properly exported.
  // The current beta/release versions of the cast extension do not export
  // stopCastMirroring, so we will also try to call the minified version.
  // See crbug.com/489929.
  ExecuteJavaScript("backgroundSetup.Qu('user-stop');");

lines_before: 
parentID: 
patch: @@ -138,8 +138,14 @@ void CastConfigDelegateChromeos::CastToReceiver(
                     "');");
 }
 
-void CastConfigDelegateChromeos::StopCasting(const std::string& activity_id) {
+void CastConfigDelegateChromeos::StopCasting() {
   ExecuteJavaScript("backgroundSetup.stopCastMirroring('user-stop');");
+
+  // TODO(jdufault): Remove this after stopCastMirroring is properly exported.
+  // The current beta/release versions of the cast extension do not export
+  // stopCastMirroring, so we will also try to call the minified version.
+  // See crbug.com/489929.
+  ExecuteJavaScript("backgroundSetup.Qu('user-stop');");
 }
 
 void CastConfigDelegateChromeos::LaunchCastOptions() {
project: Chrome
project_after: 1924f747637265f563892b8f56a64391f6208194
project_before: 04192cf91fe892f516854317886ae2227af0ccb5
vul: 1
vul_func_with_fix: void CastConfigDelegateChromeos::StopCasting(const std::string& activity_id) {
//fix_flaw_line_below:
//void CastConfigDelegateChromeos::StopCasting() {
   ExecuteJavaScript("backgroundSetup.stopCastMirroring('user-stop');");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  // TODO(jdufault): Remove this after stopCastMirroring is properly exported.
//fix_flaw_line_below:
//  // The current beta/release versions of the cast extension do not export
//fix_flaw_line_below:
//  // stopCastMirroring, so we will also try to call the minified version.
//fix_flaw_line_below:
//  // See crbug.com/489929.
//fix_flaw_line_below:
//  ExecuteJavaScript("backgroundSetup.Qu('user-stop');");
 }


========================================

